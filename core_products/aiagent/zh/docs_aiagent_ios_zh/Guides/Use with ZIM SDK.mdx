# 和 ZIM SDK 配合使用

---

AI Agent SDK 可以和 ZIM SDK 一起集成，快速实现 AI 文本聊天功能

## 准备环境
请确保开发环境满足以下要求：

- Xcode 15.0 或以上版本。
- iOS 12.0 或以上版本且支持音视频的 iOS 设备。
- iOS 设备已经连接到 Internet。

## 前提条件
- 已在 ZEGO 控制台 创建项目，获取到了接入 ZIM SDK 服务所需的 AppID、AppSign。
<Warning title="注意">
ZIM 服务权限不是默认开启的，使用前，请先在 ZEGO 控制台 自助开通 ZIM 服务（详情请参考控制台文档 项目管理 - 即时通讯），若无法开通 ZIM 服务，请联系 ZEGO 技术支持开通。
</Warning>
- 已经集成了 [AI Agent SDK](../Quick%20start/Based%20on%20%20SDK.mdx) 和 [ZIM SDK](/zh/zim-ios/send-and-receive-messages#2-集成-sdk)

## 核心能力实现

### 初始化 AI Agent SDK 和 ZIM SDK 
1. 参考[快速开始](../Quick%20start/Based%20on%20%20SDK.mdx#初始化-ai-agent-sdk)， 完成 AI Agent SDK 初始化 
2. 初始化 ZIM SDK，使用 [create](https://doc-zh.zego.im/article/api?doc=zim_API~objectivec_ios~protocol~ZIM#create-with-app-config) 创建 ZIM 实例
```objective-c
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = @"appid";// 替换为您申请到的 AppID
appConfig.appSign = @"appSign"; // 替换为您申请到的 AppSign
self.zim = [ZIM createWithAppConfig:appConfig];
```


### 创建会话

<Steps>
<Step title="登录 ZIM SDK">

在创建会话之前，需要先调用 [login](https://doc-zh.zego.im/article/api?doc=zim_API~objectivec_ios~protocol~ZIM#login-with-user-id-config-callback-2) 登录 ZIM SDK 
```objective-c
// 登录ZIM
ZIMLoginConfig *config = [[ZIMLoginConfig alloc] init];
config.userName = @"user_name";// 用户自己定义的 userName

// 用户自己定义的 userID
// 使用当前用户ID登录
[self.zim loginWithUserID:@"user_id" config:config callback:^(ZIMError * _Nonnull errorInfo) {

}];
``` 
</Step>
<Step title="创建会话">

根据预先创建并且获得的AI模版来创建会话,实现逻辑如下：

1. 使用 AIAgent SDK 接口 [queryConversationList](../Client%20API/API%20reference.mdx#queryconversationlist) 查询当前用户是否已经创建过会话，如果已经创建过会话，则不用再创建。
2. 如果没有创建过会话，则需要使用 AIAgent SDK 接口 [createConversationWithZIM](../Client%20API/API%20reference.mdx#createconversationwithzim) 来创建会话。

<Warning title="注意">
当 AI Agent SDK 和 ZIM SDK 一起使用的时候，需要使用 [createConversationWithZIM](../Client%20API/API%20reference.mdx#createconversationwithzim) 来创建会话。
</Warning>
```objective-c
- (void)requestAudioPermission:(void(^)(BOOL granted))completion {
    /// 需要在项目的 Info.plist 文件中添加麦克风权限的使用说明
    AVAudioSession *audioSession = [AVAudioSession sharedInstance];
    [audioSession requestRecordPermission:^(BOOL granted) {
        dispatch_async(dispatch_get_main_queue(), ^{
            completion(granted);
        });
    }];
}

- (void)createConversationIfNeeded:(CustomAgentConfig*)customAgentConfig
                       completion:(void(^)(ConversationConfigInfo *conversation, NSError *error))completion {
    // 1. 先查询现有会话
    [[ZegoAIAgent sharedInstance] queryConversationList:(1) pageSize:(100) complete:^(NSInteger errorCode, NSString *errMsg, QueryConversationListData * conversationListData, NSString * requestId) {
        if (errorCode != 0) {
            NSError *error = [NSError errorWithDomain:@"ZegoAIAgent" 
                                               code:errorCode 
                                           userInfo:@{NSLocalizedDescriptionKey: errMsg}];
            completion(nil, error);
            return;
        }
        
        // 2. 如果有现有会话，检查 agentTemplateId 是否匹配
        if (conversationListData && conversationListData.conversationList && conversationListData.conversationList.count > 0) {
            // 遍历会话列表，查找匹配的 agentTemplateId
            for (ConversationConfigInfo *conversation in conversationListData.conversationList) {
                if ([conversation.agentTemplatedId isEqualToString:customAgentConfig.agentTemplateId]) {
                    // 找到匹配的会话，直接返回
                    completion(conversation, nil);
                    return;
                }
            }
        }
        
        // 3. 没有找到匹配的会话，创建新会话
        [[ZegoAIAgent sharedInstance] createConversation:customAgentConfig withChatConfig:nil withCallback:^(NSInteger errorCode, NSString * _Nonnull message, ConversationConfigInfo * _Nullable conversation, NSString * _Nullable requestId) {
            if (errorCode != 0) {
                NSError *error = [NSError errorWithDomain:@"ZegoAIAgent"
                                                   code:errorCode
                                               userInfo:@{NSLocalizedDescriptionKey: message}];
                completion(nil, error);
                return;
            }
            
            completion(conversation, nil);
        }];
    }];
}

- (void)initializeConversation {
    [[ZegoAIAgentHelper sharedInstance] requestAudioPermission:^(BOOL granted) {
        if (!granted) {
            NSLog(@"未获得音频权限");
            return;
        }
        
        [[ZegoAIAgentHelper sharedInstance] createConversationIfNeeded:self.xiaoZhiConfig 
                                                          completion:^(ConversationConfigInfo *conversation, NSError *error) {
            if (error) {
                NSLog(@"创建会话失败：%@", error.localizedDescription);
                return;
            }
            
            // 保存当前的会话ID
            self.currentConversationId = conversation.agentId;
        }];
    }];
}
```
</Step>
</Steps>

### 发送和接收文本消息
完成创建会话后，即可实现发送和接收文本消息的功能。

通过 [sendMessage](https://doc-zh.zego.im/article/api?doc=zim_API~objectivec_ios~protocol~ZIM#send-message-message-to-conversation-id-conversation-type-config-notification-callback) 发送单聊消息
```objective-c
- (void)sendMessage {
    NSString *messageText = self.inputTextField.text;
    if (messageText.length == 0) {
        return;
    }
    
    // 先收起键盘
    [self.inputTextField resignFirstResponder];
    
    // 创建文本消息
    ZIMTextMessage *zimMessage = [[ZIMTextMessage alloc] init];
    zimMessage.message = messageText;
    
    // 消息发送配置
    ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
    config.priority = ZIMMessagePriorityMedium;
    
    // 消息发送通知
    ZIMMessageSendNotification *notification = [[ZIMMessageSendNotification alloc] init];
    notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
        // 发送前的回调，可以在这里提前展示UI
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.messages addObject:message];
            [self.tableView reloadData];
            [self scrollToBottom];
        });
    };
    
    // 发送消息
    [self.zim sendMessage:zimMessage 
        toConversationID:self.currentConversationId 
        conversationType:ZIMConversationTypePeer 
                  config:config 
            notification:notification
               callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        if (errorInfo.code == 0) {
            NSLog(@"消息发送成功");
            dispatch_async(dispatch_get_main_queue(), ^{
                self.inputTextField.text = @"";
            });
        } else {
            NSLog(@"消息发送失败：%@", errorInfo.message);
        }
    }];
}
```

通过 ZIM SDK 的 [setEventHandler](https://doc-zh.zego.im/article/api?doc=zim_API~objectivec_ios~protocol~ZIM#set-event-handler) 监听 [peerMessageReceived](https://doc-zh.zego.im/article/api?doc=zim_API~objectivec_ios~protocol~ZIMEventHandler#zim-peer-message-received-info-from-user-id) 回调接收单聊消息

```objective-c
// 设置事件处理器
[self.zim setEventHandler:self];

- (void)zim:(ZIM *)zim peerMessageReceived:(NSArray<ZIMMessage *> *)messageList info:(ZIMMessageReceivedInfo *)info fromUserID:(NSString *)fromUserID {
    NSLog(@"收到单聊消息，数量: %lu", (unsigned long)messageList.count);
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.messages addObjectsFromArray:messageList];
        [self.tableView reloadData];
        [self scrollToBottom];
    });
}
```

这样我们就实现了基本的 AI 文本互动功能

<Accordion title="文本聊天页面完整代码：" defaultOpen="false">

<Tabs>
<Tab title="ZIMChatViewController.h">
#import <UIKit/UIKit.h>

@interface ZIMChatViewController : UIViewController

@end 
</Tab>
<Tab title="ZIMChatViewController.m">
```objective-c
#import "ZIMChatViewController.h"
#import "ZegoAIAgentHelper.h"
#import "ZIM/ZIM.h"
#import <objc/runtime.h>

@interface ZIMChatViewController () <UITableViewDataSource, UITableViewDelegate, UITextFieldDelegate, ZIMEventHandler, UIGestureRecognizerDelegate>

// 当前会话ID
@property (nonatomic, copy) NSString *currentConversationId;
// 小智AI助手配置信息
@property (nonatomic, strong) CustomAgentConfig *xiaoZhiConfig;
// ZIM实例
@property (nonatomic, strong) ZIM *zim;

// UI组件
@property (nonatomic, strong) UITableView *tableView;
@property (nonatomic, strong) UITextField *inputTextField;
@property (nonatomic, strong) UIButton *sendButton;
@property (nonatomic, strong) UILabel *titleLabel;

// 消息数据
@property (nonatomic, strong) NSMutableArray<ZIMMessage *> *messages;

// 添加键盘处理相关属性
@property (nonatomic, strong) UIView *toolBar;  // 保存工具栏引用
@property (nonatomic, assign) CGFloat keyboardHeight;  // 保存键盘高度

@end

@implementation ZIMChatViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
    
    // 初始化消息数组
    self.messages = [NSMutableArray array];
    
    // 提前加载AI助手配置
    self.xiaoZhiConfig = [[ZegoAIAgentHelper sharedInstance] getLocalConversationConfigInfo];
    
    // 设置UI
    [self setupUI];
    
    // 初始化ZIM
    [self initializeZIM];
    
    // 初始化会话
    [self initializeConversation];
    
    // 添加键盘通知监听
    [self setupKeyboardNotifications];
}

#pragma mark - UI设置

- (void)setupUI {
    // 设置整体背景色为白色
    self.view.backgroundColor = [UIColor whiteColor];
    
    // 设置顶部导航栏样式
    UIView *navBar = [[UIView alloc] init];
    navBar.backgroundColor = [UIColor systemBlueColor];
    navBar.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:navBar];
    
    // 标题标签
    self.titleLabel = [[UILabel alloc] init];
    self.titleLabel.text = self.xiaoZhiConfig.name;
    self.titleLabel.textAlignment = NSTextAlignmentCenter;
    self.titleLabel.font = [UIFont boldSystemFontOfSize:18];
    self.titleLabel.textColor = [UIColor whiteColor];
    self.titleLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [navBar addSubview:self.titleLabel];
    
    // 关闭按钮
    UIButton *closeButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [closeButton setTitle:@"关闭" forState:UIControlStateNormal];
    [closeButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal];
    [closeButton addTarget:self action:@selector(closeButtonClicked) forControlEvents:UIControlEventTouchUpInside];
    closeButton.translatesAutoresizingMaskIntoConstraints = NO;
    [navBar addSubview:closeButton];
    
    // 创建底部工具栏
    UIView *toolBar = [[UIView alloc] init];
    self.toolBar = toolBar;  // 保存工具栏引用
    toolBar.backgroundColor = [UIColor colorWithWhite:0.95 alpha:1.0];
    toolBar.translatesAutoresizingMaskIntoConstraints = NO;
    [self.view addSubview:toolBar];
    
    // 输入框样式优化
    self.inputTextField = [[UITextField alloc] init];
    self.inputTextField.placeholder = @"请输入消息...";
    self.inputTextField.attributedPlaceholder = [[NSAttributedString alloc] 
        initWithString:@"请输入消息..." 
        attributes:@{
            NSForegroundColorAttributeName: [UIColor colorWithWhite:0.6 alpha:1.0]  // 灰色占位符
        }];
    self.inputTextField.backgroundColor = [UIColor whiteColor];
    self.inputTextField.textColor = [UIColor blackColor];  // 设置输入文字颜色
    self.inputTextField.font = [UIFont systemFontOfSize:15];  // 设置字体大小
    self.inputTextField.layer.cornerRadius = 18;
    self.inputTextField.layer.masksToBounds = YES;
    self.inputTextField.layer.borderWidth = 0.5;  // 添加边框
    self.inputTextField.layer.borderColor = [UIColor colorWithWhite:0.8 alpha:1.0].CGColor;  // 浅灰色边框
    self.inputTextField.leftView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 12, 0)];
    self.inputTextField.leftViewMode = UITextFieldViewModeAlways;
    self.inputTextField.returnKeyType = UIReturnKeySend;
    self.inputTextField.delegate = self;
    self.inputTextField.translatesAutoresizingMaskIntoConstraints = NO;
    [toolBar addSubview:self.inputTextField];
    
    // 发送按钮样式优化
    self.sendButton = [UIButton buttonWithType:UIButtonTypeSystem];
    [self.sendButton setTitle:@"发送" forState:UIControlStateNormal];
    [self.sendButton setTitleColor:[UIColor systemBlueColor] forState:UIControlStateNormal];
    [self.sendButton setTitleColor:[[UIColor systemBlueColor] colorWithAlphaComponent:0.6] forState:UIControlStateHighlighted];
    self.sendButton.titleLabel.font = [UIFont systemFontOfSize:16 weight:UIFontWeightMedium];
    [self.sendButton addTarget:self action:@selector(sendMessage) forControlEvents:UIControlEventTouchUpInside];
    self.sendButton.translatesAutoresizingMaskIntoConstraints = NO;
    [toolBar addSubview:self.sendButton];
    
    // 聊天消息列表
    self.tableView = [[UITableView alloc] init];
    self.tableView.backgroundColor = [UIColor clearColor];  // 设置为透明
    self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;
    self.tableView.dataSource = self;
    self.tableView.delegate = self;
    self.tableView.translatesAutoresizingMaskIntoConstraints = NO;
    [self.tableView registerClass:[UITableViewCell class] forCellReuseIdentifier:@"MessageCell"];
    [self.view addSubview:self.tableView];
    
    // 保存底部约束以便后续更新
    NSLayoutConstraint *toolBarBottomConstraint = [toolBar.bottomAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.bottomAnchor];
    
    // 设置约束
    [NSLayoutConstraint activateConstraints:@[
        // 导航栏约束
        [navBar.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.topAnchor],
        [navBar.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [navBar.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [navBar.heightAnchor constraintEqualToConstant:44],
        
        // 标题标签约束
        [self.titleLabel.centerXAnchor constraintEqualToAnchor:navBar.centerXAnchor],
        [self.titleLabel.centerYAnchor constraintEqualToAnchor:navBar.centerYAnchor],
        
        // 关闭按钮约束
        [closeButton.trailingAnchor constraintEqualToAnchor:navBar.trailingAnchor constant:-16],
        [closeButton.centerYAnchor constraintEqualToAnchor:navBar.centerYAnchor],
        
        // 底部工具栏约束
        [toolBar.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [toolBar.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        toolBarBottomConstraint, // 使用变量而不是直接创建约束
        [toolBar.heightAnchor constraintEqualToConstant:60],
        
        // 输入框约束
        [self.inputTextField.leadingAnchor constraintEqualToAnchor:toolBar.leadingAnchor constant:16],
        [self.inputTextField.centerYAnchor constraintEqualToAnchor:toolBar.centerYAnchor],
        [self.inputTextField.trailingAnchor constraintEqualToAnchor:self.sendButton.leadingAnchor constant:-8],
        [self.inputTextField.heightAnchor constraintEqualToConstant:36],
        
        // 发送按钮约束
        [self.sendButton.trailingAnchor constraintEqualToAnchor:toolBar.trailingAnchor constant:-16],
        [self.sendButton.centerYAnchor constraintEqualToAnchor:toolBar.centerYAnchor],
        [self.sendButton.widthAnchor constraintEqualToConstant:60],
        
        // 表格视图约束
        [self.tableView.topAnchor constraintEqualToAnchor:navBar.bottomAnchor],
        [self.tableView.leadingAnchor constraintEqualToAnchor:self.view.leadingAnchor],
        [self.tableView.trailingAnchor constraintEqualToAnchor:self.view.trailingAnchor],
        [self.tableView.bottomAnchor constraintEqualToAnchor:toolBar.topAnchor]
    ]];
    
    // 保存底部约束以便键盘处理
    objc_setAssociatedObject(self.toolBar, "bottomConstraint", toolBarBottomConstraint, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    
    // 添加点击手势来关闭键盘
    [self setupTapGesture];
}

#pragma mark - ZIM初始化和聊天

- (void)initializeConversation {
    [[ZegoAIAgentHelper sharedInstance] requestAudioPermission:^(BOOL granted) {
        if (!granted) {
            NSLog(@"未获得音频权限");
            return;
        }
        
        [[ZegoAIAgentHelper sharedInstance] createConversationIfNeeded:self.xiaoZhiConfig 
                                                          completion:^(ConversationConfigInfo *conversation, NSError *error) {
            if (error) {
                NSLog(@"创建会话失败：%@", error.localizedDescription);
                return;
            }
            
            // 保存会话ID
            self.currentConversationId = conversation.agentId;
        }];
    }];
}

- (void)initializeZIM {
    // 创建ZIM实例
    ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
    appConfig.appID = $appid; // 填入实际的appID
    appConfig.appSign = $appsign; // 填入实际的appSign
    self.zim = [ZIM createWithAppConfig:appConfig];
    
    // 设置事件处理器
    [self.zim setEventHandler:self];
    
    // 登录ZIM
    ZIMLoginConfig *config = [[ZIMLoginConfig alloc] init];
    config.userName = $user_name;
    
    // 使用当前用户ID登录
    [self.zim loginWithUserID:$user_id config:config callback:^(ZIMError * _Nonnull errorInfo) {
        if (errorInfo.code == 0) {
            NSLog(@"ZIM登录成功");
        } else {
            NSLog(@"ZIM登录失败：%@", errorInfo.message);
        }
    }];
}

#pragma mark - 消息发送和接收

- (void)sendMessage {
    NSString *messageText = self.inputTextField.text;
    if (messageText.length == 0) {
        return;
    }
    
    // 先收起键盘
    [self.inputTextField resignFirstResponder];
    
    // 创建文本消息
    ZIMTextMessage *zimMessage = [[ZIMTextMessage alloc] init];
    zimMessage.message = messageText;
    
    // 消息发送配置
    ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
    config.priority = ZIMMessagePriorityMedium;
    
    // 消息发送通知
    ZIMMessageSendNotification *notification = [[ZIMMessageSendNotification alloc] init];
    notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
        // 发送前的回调，可以在这里提前展示UI
        dispatch_async(dispatch_get_main_queue(), ^{
            [self.messages addObject:message];
            [self.tableView reloadData];
            [self scrollToBottom];
        });
    };
    
    // 发送消息
    [self.zim sendMessage:zimMessage 
        toConversationID:self.currentConversationId 
        conversationType:ZIMConversationTypePeer 
                  config:config 
            notification:notification
               callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        if (errorInfo.code == 0) {
            NSLog(@"消息发送成功");
            dispatch_async(dispatch_get_main_queue(), ^{
                self.inputTextField.text = @"";
            });
        } else {
            NSLog(@"消息发送失败：%@", errorInfo.message);
        }
    }];
}

#pragma mark - UITableViewDataSource

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return self.messages.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    ZIMMessage *message = self.messages[indexPath.row];
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"MessageCell" forIndexPath:indexPath];
    
    // 设置单元格背景为透明
    cell.backgroundColor = [UIColor clearColor];
    cell.contentView.backgroundColor = [UIColor clearColor];
    
    // 清除现有子视图
    for (UIView *subview in cell.contentView.subviews) {
        [subview removeFromSuperview];
    }
    
    // 创建气泡视图
    UIView *bubbleView = [[UIView alloc] init];
    bubbleView.layer.cornerRadius = 12;
    bubbleView.translatesAutoresizingMaskIntoConstraints = NO;
    [cell.contentView addSubview:bubbleView];
    
    // 创建消息标签
    UILabel *messageLabel = [[UILabel alloc] init];
    messageLabel.numberOfLines = 0;
    messageLabel.font = [UIFont systemFontOfSize:15];
    messageLabel.translatesAutoresizingMaskIntoConstraints = NO;
    [bubbleView addSubview:messageLabel];
    
    // 设置消息内容
    if ([message isKindOfClass:[ZIMTextMessage class]]) {
        ZIMTextMessage *textMessage = (ZIMTextMessage *)message;
        messageLabel.text = textMessage.message;
    }
    
    // 判断是发送还是接收的消息
    BOOL isSentMessage = [message.senderUserID isEqualToString:$user_id];
    
    if (isSentMessage) {
        // 发送的消息 - 蓝色气泡，白色文字
        bubbleView.backgroundColor = [UIColor systemBlueColor];
        messageLabel.textColor = [UIColor whiteColor];
        
        // 设置约束 - 右侧对齐
        [NSLayoutConstraint activateConstraints:@[
            [bubbleView.topAnchor constraintEqualToAnchor:cell.contentView.topAnchor constant:8],
            [bubbleView.trailingAnchor constraintEqualToAnchor:cell.contentView.trailingAnchor constant:-16],
            [bubbleView.widthAnchor constraintLessThanOrEqualToConstant:250],
            [bubbleView.bottomAnchor constraintEqualToAnchor:cell.contentView.bottomAnchor constant:-8],
            
            [messageLabel.topAnchor constraintEqualToAnchor:bubbleView.topAnchor constant:8],
            [messageLabel.leadingAnchor constraintEqualToAnchor:bubbleView.leadingAnchor constant:12],
            [messageLabel.trailingAnchor constraintEqualToAnchor:bubbleView.trailingAnchor constant:-12],
            [messageLabel.bottomAnchor constraintEqualToAnchor:bubbleView.bottomAnchor constant:-8]
        ]];
    } else {
        // 接收的消息 - 浅灰色气泡，深色文字
        bubbleView.backgroundColor = [UIColor colorWithWhite:0.95 alpha:1.0];
        messageLabel.textColor = [UIColor blackColor];
        
        // 设置约束 - 左侧对齐
        [NSLayoutConstraint activateConstraints:@[
            [bubbleView.topAnchor constraintEqualToAnchor:cell.contentView.topAnchor constant:8],
            [bubbleView.leadingAnchor constraintEqualToAnchor:cell.contentView.leadingAnchor constant:16],
            [bubbleView.widthAnchor constraintLessThanOrEqualToConstant:250],
            [bubbleView.bottomAnchor constraintEqualToAnchor:cell.contentView.bottomAnchor constant:-8],
            
            [messageLabel.topAnchor constraintEqualToAnchor:bubbleView.topAnchor constant:8],
            [messageLabel.leadingAnchor constraintEqualToAnchor:bubbleView.leadingAnchor constant:12],
            [messageLabel.trailingAnchor constraintEqualToAnchor:bubbleView.trailingAnchor constant:-12],
            [messageLabel.bottomAnchor constraintEqualToAnchor:bubbleView.bottomAnchor constant:-8]
        ]];
    }
    
    // 禁用单元格的选中状态
    cell.selectionStyle = UITableViewCellSelectionStyleNone;
    
    return cell;
}

#pragma mark - UITableViewDelegate

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    return UITableViewAutomaticDimension;
}

- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath {
    return 60;
}

#pragma mark - UITextFieldDelegate

- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    [self sendMessage];
    return YES;
}

#pragma mark - ZIMEventHandler

- (void)zim:(ZIM *)zim errorInfo:(ZIMError *)errorInfo {
    NSLog(@"ZIM错误: %@", errorInfo.message);
}

- (void)zim:(ZIM *)zim connectionStateChanged:(ZIMConnectionState)state event:(ZIMConnectionEvent)event extendedData:(NSDictionary *)extendedData {
    NSLog(@"ZIM连接状态变化: %ld", (long)state);
}

- (void)zim:(ZIM *)zim peerMessageReceived:(NSArray<ZIMMessage *> *)messageList info:(ZIMMessageReceivedInfo *)info fromUserID:(NSString *)fromUserID {
    NSLog(@"收到单聊消息，数量: %lu", (unsigned long)messageList.count);
    
    dispatch_async(dispatch_get_main_queue(), ^{
        [self.messages addObjectsFromArray:messageList];
        [self.tableView reloadData];
        [self scrollToBottom];
    });
}

#pragma mark - 辅助方法

- (void)scrollToBottom {
    NSInteger lastRow = [self.tableView numberOfRowsInSection:0] - 1;
    if (lastRow >= 0) {
        NSIndexPath *indexPath = [NSIndexPath indexPathForRow:lastRow inSection:0];
        [self.tableView scrollToRowAtIndexPath:indexPath 
                            atScrollPosition:UITableViewScrollPositionBottom 
                                  animated:YES];
    }
}

- (void)closeButtonClicked {
    // 退出登录
    [self.zim logout];
    
    // 关闭视图控制器
    [self dismissViewControllerAnimated:YES completion:nil];
}

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    
    // 退出登录
    [self.zim logout];
    
    // 销毁ZIM实例
    [self.zim destroy];
}

#pragma mark - 键盘处理

- (void)setupKeyboardNotifications {
    // 监听键盘显示通知
    [[NSNotificationCenter defaultCenter] addObserver:self
                                           selector:@selector(keyboardWillShow:)
                                               name:UIKeyboardWillShowNotification
                                             object:nil];
    
    // 监听键盘隐藏通知
    [[NSNotificationCenter defaultCenter] addObserver:self
                                           selector:@selector(keyboardWillHide:)
                                               name:UIKeyboardWillHideNotification
                                             object:nil];
}

- (void)keyboardWillShow:(NSNotification *)notification {
    // 获取键盘高度
    CGRect keyboardFrame = [notification.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];
    self.keyboardHeight = keyboardFrame.size.height;
    
    // 获取动画时间和曲线
    NSTimeInterval duration = [notification.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];
    UIViewAnimationCurve curve = [notification.userInfo[UIKeyboardAnimationCurveUserInfoKey] integerValue];
    
    // 获取保存的底部约束
    NSLayoutConstraint *toolBarBottomConstraint = objc_getAssociatedObject(self.toolBar, "bottomConstraint");
    
    // 更新约束
    toolBarBottomConstraint.constant = -self.keyboardHeight;
    
    // 使用与键盘相同的动画参数
    [UIView beginAnimations:nil context:NULL];
    [UIView setAnimationDuration:duration];
    [UIView setAnimationCurve:curve];
    [UIView setAnimationBeginsFromCurrentState:YES];
    
    [self.view layoutIfNeeded];
    [self scrollToBottom];
    
    [UIView commitAnimations];
}

- (void)keyboardWillHide:(NSNotification *)notification {
    // 获取动画时间和曲线
    NSTimeInterval duration = [notification.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];
    UIViewAnimationCurve curve = [notification.userInfo[UIKeyboardAnimationCurveUserInfoKey] integerValue];
    
    // 获取保存的底部约束
    NSLayoutConstraint *toolBarBottomConstraint = objc_getAssociatedObject(self.toolBar, "bottomConstraint");
    
    // 重置约束
    toolBarBottomConstraint.constant = 0;
    
    // 使用与键盘相同的动画参数
    [UIView beginAnimations:nil context:NULL];
    [UIView setAnimationDuration:duration];
    [UIView setAnimationCurve:curve];
    [UIView setAnimationBeginsFromCurrentState:YES];
    
    [self.view layoutIfNeeded];
    
    [UIView commitAnimations];
}

// 修改点击手势的设置方法
- (void)setupTapGesture {
    UITapGestureRecognizer *tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(handleTapGesture:)];
    tapGesture.cancelsTouchesInView = NO;
    
    // 添加手势代理
    tapGesture.delegate = self;
    
    // 将手势添加到tableView而不是整个view
    [self.tableView addGestureRecognizer:tapGesture];
}

// 实现手势代理方法
- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch {
    // 如果点击的是发送按钮，不触发手势
    if ([touch.view isDescendantOfView:self.sendButton]) {
        return NO;
    }
    // 如果点击的是输入框，不触发手势
    if ([touch.view isDescendantOfView:self.inputTextField]) {
        return NO;
    }
    return YES;
}

- (void)handleTapGesture:(UITapGestureRecognizer *)gesture {
    if (gesture.state == UIGestureRecognizerStateEnded) {
        [self.view endEditing:YES];
    }
}

- (void)dealloc {
    // 移除键盘通知监听
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}

@end 
```
</Tab>
</Tabs>

</Accordion>
