# 获取AI状态&字幕

---

本文介绍如何通过监听 RTC 的 IMRecvCustomCommand 回调获取 AI 状态和字幕。

## 功能概述

通过监听 IMRecvCustomCommand 回调，您可以：
1. 获取用户和 AI 的说话状态（开始/结束）
2. 获取实时语音转文字的字幕内容
3. 跟踪对话轮次

## 消息格式说明

通过 Express SDK 的 IMRecvCustomCommand 回调接收到的消息格式如下：

```objc
// 聊天消息基类
@interface ZegoAIChatMessage : NSObject

@property (nonatomic, assign) long timestamp;        // 时间戳
@property (nonatomic, assign) long long seqId;       // 序列号
@property (nonatomic, assign) long long round;       // 对话轮次
@property (nonatomic, assign) ZegoAIChatMessageType type; // 消息类型

@end

// 文本消息基类
@interface ZegoAITextMessage : ZegoAIChatMessage

@property (nonatomic, copy) NSString *text;          // 文本内容
@property (nonatomic, copy) NSString *messageId;     // 消息ID
@property (nonatomic, assign) BOOL endFlag;          // 结束标志

@end
```

### 命令类型说明

```objc
typedef NS_ENUM(NSInteger, ZegoAIChatMessageType) {
    ZegoAIChatMessageTypeUserSpeakStatus = 1,    // 用户说话状态
    ZegoAIChatMessageTypeAISpeakStatus = 2,      // AI说话状态
    ZegoAIChatMessageTypeUserText = 3,           // 用户说话文本
    ZegoAIChatMessageTypeAIText = 4,             // AI回答文本
};
```

## 展示 command 文本消息

1. 确保已正确初始化 RTC 引擎并成功加入房间。
2. 收到 Express SDK 的 IMRecvCustomCommand 回调后开始进行消息的处理：

```objc
#pragma mark - ZegoEventHandler

- (void)onIMRecvCustomCommand:(NSString *)userId command:(NSString *)command {
    // 解析JSON命令
    NSDictionary *msgDict = [ZegoAIAgentUtil dictFromJson:command];
    if (!msgDict) {
        NSLog(@"解析自定义命令: JSON解析失败");
        return;
    }
    
    // 提取基本信息
    int cmd = [msgDict[@"cmd"] intValue];
    
    switch (cmd) {
        case ZegoAIChatMessageTypeUserSpeakStatus:
        case ZegoAIChatMessageTypeAISpeakStatus:
            [self handleSpeakStatus:msgDict];
            break;
            
        case ZegoAIChatMessageTypeUserText:
            [self handleUserText:msgDict];
            break;
            
        case ZegoAIChatMessageTypeAIText:
            [self handleAIText:msgDict];
            break;
            
        default:
            break;
    }
}
```

### 处理说话状态 (cmd == 1 或 cmd == 2)

```objc
- (void)updateStatusLabel:(ZegoAIChatSessionState)state {
    NSString *statusText = @"";
    
    switch (state) {
        case ZegoAIChatSessionStateIdle:
            statusText = @"等待对话...";
            break;
            
        case ZegoAIChatSessionStateUserSpeaking:
            statusText = @"您正在说话...";
            break;
            
        case ZegoAIChatSessionStateAIListening:
            statusText = @"AI 正在听...";
            break;
            
        case ZegoAIChatSessionStateAIThinking:
            statusText = @"AI 正在思考...";
            break;
            
        case ZegoAIChatSessionStateAISpeaking:
            statusText = @"AI 正在回答...";
            break;
    }
    
    self.statusLabel.text = statusText;
}
```

### 处理用户文本 (cmd == 3)

```objc
- (void)handleUserText:(NSDictionary *)dataMap {
    NSString *content = dataMap[@"text"];
    NSString *messageId = dataMap[@"message_id"];
    BOOL endFlag = [dataMap[@"end_flag"] boolValue];
    long long seqId = [dataMap[@"seq_id"] longLongValue];
    
    // 创建用户文本消息
    ZegoAIUserTextMessage *textMsg = [[ZegoAIUserTextMessage alloc] init];
    textMsg.text = content;
    textMsg.messageId = messageId;
    textMsg.endFlag = endFlag;
    textMsg.seqId = seqId;
    
    // 添加到会话，注意处理消息更新或替换
    // 相同的 message_id 取 seq_id 最大的消息进行覆盖，只显示 seq_id 最大的 message 的文本
    // 这个逻辑在 addMessage 方法中实现
    [self.session addMessage:textMsg];
    
    // 通知UI更新
    if ([self.delegate respondsToSelector:@selector(onUserTextMessageReceived:)]) {
        [self.delegate onUserTextMessageReceived:textMsg];
    }
}
```

### 处理AI文本 (cmd == 4)

```objc
- (void)handleAIText:(NSDictionary *)dataMap {
    NSString *content = dataMap[@"text"];
    NSString *messageId = dataMap[@"message_id"];
    BOOL endFlag = [dataMap[@"end_flag"] boolValue];
    long long seqId = [dataMap[@"seq_id"] longLongValue];
    
    // 创建AI文本消息
    ZegoAIAITextMessage *textMsg = [[ZegoAIAITextMessage alloc] init];
    textMsg.text = content;
    textMsg.messageId = messageId;
    textMsg.endFlag = endFlag;
    textMsg.seqId = seqId;
    
    // 添加到会话，注意合并相同messageId的文本
    // 相同的 message_id 按照 seq_id 进行排序，然后合并文本进行显示
    // 这个逻辑在 addMessage 方法中实现
    [self.session addMessage:textMsg];
    
    // 通知UI更新
    if ([self.delegate respondsToSelector:@selector(onAITextMessageReceived:)]) {
        [self.delegate onAITextMessageReceived:textMsg];
    }
}
```

消息管理实现：

```objc
- (void)addMessage:(ZegoAITextMessage *)message {
    // 检查是否已存在相同messageId的消息
    NSInteger existingIndex = -1;
    
    for (NSInteger i = 0; i < self.messages.count; i++) {
        ZegoAITextMessage *existingMsg = self.messages[i];
        if ([existingMsg.messageId isEqualToString:message.messageId]) {
            existingIndex = i;
            break;
        }
    }
    
    if (existingIndex >= 0) {
        // 如果是AI消息，我们合并文本内容
        if ([message isKindOfClass:[ZegoAIAITextMessage class]]) {
            ZegoAITextMessage *existingMsg = self.messages[existingIndex];
            
            if (message.text.length > 0) {
                if (existingMsg.text.length > 0) {
                    existingMsg.text = [existingMsg.text stringByAppendingString:message.text];
                } else {
                    existingMsg.text = message.text;
                }
            } 
            existingMsg.endFlag = message.endFlag;
        } else {
            [self.messages replaceObjectAtIndex:existingIndex withObject:message];
        }
    } else {
        if (message.text.length > 0) {
            [self.messages addObject:message];
        } 
    }
}
```