# 展示 AI 状态和字幕

---

本文介绍如何通过监听 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-im-recv-custom-command-from-user-room-id) 回调展示 AI 状态和字幕。

## 功能概述

通过监听 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-im-recv-custom-command-from-user-room-id) 回调，您可以：
- 获取用户和 AI 的说话状态（开始/结束）；
- 获取实时语音转文字的字幕内容；
- 跟踪对话轮次。

## 消息格式说明

通过 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-im-recv-custom-command-from-user-room-id) 回调接收到的消息格式如下：

```objc
// 聊天消息基类
@interface ZegoAIChatMessage : NSObject

@property (nonatomic, assign) long timestamp;             // 时间戳
@property (nonatomic, assign) long long seqId;            // 序列号
@property (nonatomic, assign) long long round;            // 对话轮次
@property (nonatomic, assign) ZegoAIChatMessageType type; // 命令类型

@end

// 文本消息基类
@interface ZegoAITextMessage : ZegoAIChatMessage

@property (nonatomic, copy) NSString *text;          // 文本内容
@property (nonatomic, copy) NSString *messageId;     // 消息 ID
@property (nonatomic, assign) BOOL endFlag;          // 结束标志

@end
```

### 命令类型说明

ZegoAIChatMessageType 枚举类型定义了四种命令类型：

```objc
typedef NS_ENUM(NSInteger, ZegoAIChatMessageType) {
    ZegoAIChatMessageTypeUserSpeakStatus = 1,    // 用户说话状态
    ZegoAIChatMessageTypeAISpeakStatus = 2,      // AI 说话状态
    ZegoAIChatMessageTypeUserText = 3,           // 用户说话文本
    ZegoAIChatMessageTypeAIText = 4,             // AI 回答文本
};

```

## 展示 AI 状态和字幕


收到 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-im-recv-custom-command-from-user-room-id) 回调后开始进行消息的处理：

<Note title="说明">确保已正确初始化 ZEGO Express SDK 并成功加入 RTC 房间。</Note>


```objc
#pragma mark - ZegoEventHandler

- (void)onIMRecvCustomCommand:(NSString *)userId command:(NSString *)command {
    // 解析JSON命令
    NSDictionary *msgDict = [ZegoAIAgentUtil dictFromJson:command];
    if (!msgDict) {
        NSLog(@"解析自定义命令: JSON解析失败");
        return;
    }
    
    // 提取基本信息
    int cmd = [msgDict[@"cmd"] intValue];
    
    switch (cmd) {
        case ZegoAIChatMessageTypeUserSpeakStatus:
        case ZegoAIChatMessageTypeAISpeakStatus:
            [self handleSpeakStatus:msgDict];
            break;
            
        case ZegoAIChatMessageTypeUserText:
            [self handleUserText:msgDict];
            break;
            
        case ZegoAIChatMessageTypeAIText:
            [self handleAIText:msgDict];
            break;
            
        default:
            break;
    }
}
```

### 不同的命令状态处理方式

<Tabs>
<Tab title="cmd 为 1 或 cmd 为 2">
处理用户说话状态 
```objc
- (void)updateStatusLabel:(ZegoAIChatSessionState)state {
    NSString *statusText = @"";
    
    switch (state) {
        case ZegoAIChatSessionStateIdle:
            statusText = @"等待对话...";
            break;
            
        case ZegoAIChatSessionStateUserSpeaking:
            statusText = @"您正在说话...";
            break;
            
        case ZegoAIChatSessionStateAIListening:
            statusText = @"AI 正在听...";
            break;
            
        case ZegoAIChatSessionStateAIThinking:
            statusText = @"AI 正在思考...";
            break;
            
        case ZegoAIChatSessionStateAISpeaking:
            statusText = @"AI 正在回答...";
            break;
    }
    
    self.statusLabel.text = statusText;
}
```

</Tab>
<Tab title="cmd 为 3">
处理用户文本 
```objc
- (void)handleUserText:(NSDictionary *)dataMap {
    NSString *content = dataMap[@"text"];
    NSString *messageId = dataMap[@"message_id"];
    BOOL endFlag = [dataMap[@"end_flag"] boolValue];
    long long seqId = [dataMap[@"seq_id"] longLongValue];
    
    // 创建用户文本消息
    ZegoAIUserTextMessage *textMsg = [[ZegoAIUserTextMessage alloc] init];
    textMsg.text = content;
    textMsg.messageId = messageId;
    textMsg.endFlag = endFlag;
    textMsg.seqId = seqId;
    
    // 添加到会话，注意处理消息更新或替换
    // 相同的 message_id 取 seq_id 最大的消息进行覆盖，只显示 seq_id 最大的 message 的文本
    // 这个逻辑在 addMessage 方法中实现
    [self.session addMessage:textMsg];
    
    // 通知UI更新
    if ([self.delegate respondsToSelector:@selector(onUserTextMessageReceived:)]) {
        [self.delegate onUserTextMessageReceived:textMsg];
    }
}
```

</Tab>
<Tab title="cmd 为 4">
处理 AI 文本 
```objc
- (void)handleAIText:(NSDictionary *)dataMap {
    NSString *content = dataMap[@"text"];
    NSString *messageId = dataMap[@"message_id"];
    BOOL endFlag = [dataMap[@"end_flag"] boolValue];
    long long seqId = [dataMap[@"seq_id"] longLongValue];
    
    // 创建AI文本消息
    ZegoAIAITextMessage *textMsg = [[ZegoAIAITextMessage alloc] init];
    textMsg.text = content;
    textMsg.messageId = messageId;
    textMsg.endFlag = endFlag;
    textMsg.seqId = seqId;
    
    // 添加到会话，注意合并相同messageId的文本
    // 相同的 message_id 按照 seq_id 进行排序，然后合并文本进行显示
    // 这个逻辑在 addMessage 方法中实现
    [self.session addMessage:textMsg];
    
    // 通知UI更新
    if ([self.delegate respondsToSelector:@selector(onAITextMessageReceived:)]) {
        [self.delegate onAITextMessageReceived:textMsg];
    }
}
```

管理消息：

```objc
- (void)addMessage:(ZegoAITextMessage *)message {
    // 检查是否已存在相同messageId的消息
    NSInteger existingIndex = -1;
    
    for (NSInteger i = 0; i < self.messages.count; i++) {
        ZegoAITextMessage *existingMsg = self.messages[i];
        if ([existingMsg.messageId isEqualToString:message.messageId]) {
            existingIndex = i;
            break;
        }
    }
    
    if (existingIndex >= 0) {
        // 如果是AI消息，我们合并文本内容
        if ([message isKindOfClass:[ZegoAIAITextMessage class]]) {
            ZegoAITextMessage *existingMsg = self.messages[existingIndex];
            
            if (message.text.length > 0) {
                if (existingMsg.text.length > 0) {
                    existingMsg.text = [existingMsg.text stringByAppendingString:message.text];
                } else {
                    existingMsg.text = message.text;
                }
            } 
            existingMsg.endFlag = message.endFlag;
        } else {
            [self.messages replaceObjectAtIndex:existingIndex withObject:message];
        }
    } else {
        if (message.text.length > 0) {
            [self.messages addObject:message];
        } 
    }
}
```

</Tab>
</Tabs>

