# 展示 AI 状态和字幕

---

本文介绍如何通过监听 ZEGO Express SDK 的 [IMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~javascript_web~interface~ZegoRTMEvent#im-recv-custom-command) 回调展示 AI 状态和字幕。

## 功能概述

通过监听 [IMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~javascript_web~interface~ZegoRTMEvent#im-recv-custom-command) 回调，您可以：
- 获取用户和 AI 的说话状态（开始/结束）；
- 获取实时语音转文字的字幕内容；
- 跟踪对话轮次。

## 消息格式说明

通过 [IMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~javascript_web~interface~ZegoRTMEvent#im-recv-custom-command) 回调接收到的消息格式如下：

```typescript
interface CommandMessage {
  cmd: number;        // 命令类型
  seq_id: number;     // 消息序列号，保证有序性，不保证连续性
  timestamp:number;   // 时间戳
  data: {
    speak_status?: number;  // 说话状态：1-开始说话，2-结束说话
    text?: string;         //  语音转文字内容，每次下发增量文本答案。当 cmd 为 3 或 4 才返回
    end_flag?: boolean;    // 结束标识。true 表示本轮 LLM 文本已发送结束。当 cmd 为 3 或 4 才返回
    message_id: string;    // 消息 ID。每轮LLM 文本消息 ID 唯一。当 cmd 为 3 或 4 才返回
  };
  round?: number;   // 对话轮次，每次用户主动说话，轮次增加。保证有序性，不保证连续性
}
```

### 命令类型说明

- `cmd` 为 1：用户说话状态
- `cmd` 为 2：AI 说话状态
- `cmd` 为 3：用户说话文本内容
- `cmd` 为 4：AI 说话文本内容

```js
// 监听 IMRecvCustomCommand 回调， zg 是 ZEGO Express SDK 的实例
zg.on('IMRecvCustomCommand', (command) => {
    try {
        handleRoomCommandMessage(command);
    } catch (error) {
        console.error('处理房间命令消息失败:', error);
    }
});


/**
 * 处理房间命令消息
 * @param {Object} message - 接收到的消息对象
 */
function handleRoomCommandMessage(message) {
  const msg = JSON.parse(message);
  const { cmd, seq_id, data, round } = msg;

  switch (cmd) {
    // 用户说话状态处理
    case 1:
      // data.speak_status 1:开始说话 2:结束说话
      break;

    // 智能体说话状态处理
    case 2:
      // data.speak_status 1:开始说话 2:结束说话
      break;

    // 用户说话文本处理
    case 3:
      // 处理用户说话文本
      break;

    // 智能体说话文本处理
    case 4:
      // 处理智能体说话文本
      break;

    default:
      console.warn(`Unknown command: ${cmd}`);
  }
}

```

## 完整代码示例和使用说明

<Accordion title="完整代码示例" defaultOpen="false">

```typescript
// 状态类型定义
type SignalStatus = 'listening' | 'thinking' | 'speaking';

// 消息类型定义
interface Message {
  sender: 'user' | 'bot';
  message_id: string;
  seq_id: number;
  content: string;
  type: string;
}

// 响应式变量声明
const messages = ref<Message[]>([]);
const currentStatus = ref<SignalStatus>('listening');
const userMsgSeq = ref(0);
const currentRound = ref(0);
const botMsgMap = ref<Record<number, string>>({});

// 监听 IMRecvCustomCommand 回调， zg 是 ZEGO Express SDK 的实例
zg.on('IMRecvCustomCommand', (command) => {
    try {
        handleRoomCommandMessage(command);
    } catch (error) {
        console.error('处理房间命令消息失败:', error);
    }
});


/**
 * 处理房间命令消息
 * @param {Object} message - 接收到的消息对象
 */
function handleRoomCommandMessage(message) {
  const msg = JSON.parse(message);
  const { cmd, seq_id, data, round } = msg;

  switch (cmd) {
    // 用户说话状态处理
    case 1:
      // data.speak_status 1:开始说话 2:结束说话
      break;

    // 智能体说话状态处理
    case 2:
      // data.speak_status 1:开始说话 2:结束说话
      break;

    // 用户说话文本处理
    case 3:
      handleUserMessage(seq_id, data);
      break;

    // 智能体说话文本处理
    case 4:
      handleBotMessage(seq_id, data, round);
      break;

    default:
      console.warn(`Unknown command: ${cmd}`);
  }
}

// 处理用户消息
function handleUserMessage(seq_id, data) {
  if (seq_id > userMsgSeq.value) {
    if (data.end_flag) {
      currentRound.value++;
    }
    const asrText = data.text;
    const messageId = data.message_id;
    addOrUpdateMessage({
      sender: "user",
      message_id: messageId,
      seq_id: seq_id,
      content: asrText,
      type: "message",
    });
    userMsgSeq.value = seq_id;
  }
}

// 处理智能体消息
function handleBotMessage(seq_id, data, round) {
  const llmEndFlag = data.end_flag;
  const llmText = data.text;
  const llmMessageId = data.message_id;
  addOrUpdateMessage({
    sender: "bot",
    message_id: llmMessageId,
    seq_id: seq_id,
    content: llmText,
    type: "message",
  });
}

/**
 * 添加或更新消息
 * 只有当消息内容不为空时才添加或更新
 */
function addOrUpdateMessage(newMessage) {
  // 如果消息内容为空，直接返回
  if (!newMessage.content?.trim()) {
    return;
  }

  const isBotMessage = newMessage.sender === "bot";
  const index = messages.value.findIndex(
    (message) => message.message_id === newMessage.message_id
  );

  // 如果消息已经存在
  if (index !== -1) {
    if (isBotMessage) {
      botMsgMap.value[newMessage.seq_id] = newMessage.content;

      // 根据 seq_id 排序并生成新的消息内容
      const sortedMessages = Object.entries(botMsgMap.value)
        .sort((a, b) => a[0] - b[0]) // 按 seq_id 排序
        .map(([, value]) => value) // 提取内容
        .join(""); // 将内容连接成字符串

      // 只有当排序后的消息内容不为空时才更新
      if (sortedMessages.trim()) {
        messages.value[index].content = sortedMessages;
      }
    } else {
      // 用户消息更新，只有当新消息不为空时才更新
      if (newMessage.content.trim()) {
        messages.value[index].content = newMessage.content;
      }
    }
  } else {
    // 如果是新的消息，只有当内容不为空时才添加
    if (isBotMessage) {
      botMsgMap.value[newMessage.seq_id] = newMessage.content;
    }
    messages.value.push(newMessage);
  }
}
```

</Accordion>


### 使用说明

- 确保已正确初始化 ZEGO Express SDK 并成功加入房间。
- 实现上述完整代码示例中的状态管理和消息处理逻辑。
- 在您的界面中可以通过监听 `currentStatus` 来展示当前的交互状态：
  - `listening`: 正在聆听用户说话。
  - `thinking`: 正在思考或处理用户输入。
  - `speaking`: AI 正在说话。
- 通过 `messages` 数组获取完整的对话历史，可用于展示对话内容。

### 错误处理

代码中已包含以下基本的错误处理机制：
- 消息解析错误处理。
- 命令处理错误捕获。
- 空消息过滤。
- 消息重复处理避免。

### 注意事项

- 确保正确处理消息序列号（seq_id），以保证消息按正确顺序显示。
- AI 消息可能分多次返回，需要通过 seq_id 排序后合并显示。
- 注意处理 end_flag 标志，它表示当前轮次的消息是否结束。
- 建议在界面上通过不同的视觉效果展示不同的状态，提升用户体验。