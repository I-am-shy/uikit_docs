# 展示 AI 状态和字幕

---

本文介绍如何通过监听 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~java_android~class~IZegoEventHandler#on-im-recv-barrage-message) 回调展示 AI 状态和字幕。

## 功能概述

通过监听 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~java_android~class~IZegoEventHandler#on-im-recv-custom-command) 回调，您可以：
- 获取用户和 AI 的说话状态（开始/结束）；
- 获取实时语音转文字的字幕内容；
- 跟踪对话轮次。

## 消息格式说明

通过 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~java_android~class~IZegoEventHandler#on-im-recv-custom-command) 回调接收到的消息格式如下：

```java
public class AudioChatTextMessage {

    public long timestamp;  // 时间戳
    public int seq_id;      // 消息序列号
    public int round;       // 对话轮次
    public int cmd;         // 命令类型
    public Data data;

    public static class Data {

        public int speak_status;  // 说话状态：1-开始说话，2-结束说话
        public String text;       // 语音转文字内容
        public String message_id; // 是否是最后一条消息
        public boolean end_flag;  // 消息唯一标识
    }
}
```
### 命令类型说明

- cmd 为 1: 用户说话状态
- cmd 为 2: AI 说话状态
- cmd 为 3: 用户说话文本内容
- cmd 为 4: AI 说话文本内容

## 展示 AI 状态和字幕

1. 确保已正确初始化 ZEGO Express SDK 并成功加入房间。
2. 收到 ZEGO Express SDK 的 [onIMRecvCustomCommand](https://doc-zh.zego.im/article/api?doc=Express_Audio_SDK_API~java_android~class~IZegoEventHandler#on-im-recv-custom-command) 回调后开始进行消息的处理：

```java
public void onIMRecvCustomCommand(String roomID, ZegoUser fromUser, String command) {
    super.onIMRecvCustomCommand(roomID, fromUser, command);

    try {
        AudioChatTextMessage roomMessage = gson.fromJson(command, AudioChatTextMessage.class);
        switch (roomMessage.cmd) {
            case 1:  
                onChatStateChanged(chatSessionState);        
                break;
            case 2:
                onChatStateChanged(chatSessionState);
                break;
            case 3:
                //  收到 asr 文本（右边），更新聊天信息
                onAsrChatMsgRecved(message);
                break;
            case 4:
                // 收到 LLM 文本(左边)，更新聊天信息
                onLLMChatMsgRecved(message);
                break;
            default:
                break;
        }
    } catch (Exception e) {

    }
}
```

<Tabs>
<Tab title="cmd 为 1 或者 cmd 为 2">
对于 cmd 为 1 或者 cmd 为 2，可以在 UI 上展示当前的状态：
```java
protected void onChatStateChanged(ChatSessionState chatSessionState) {
    if (chatSessionState == ChatSessionState.AI_LISTEN) {
        updateStatusText("正在听...");
    } else if (chatSessionState == ChatSessionState.AI_THINKING) {
        updateStatusText("正在想...");
    } else if (chatSessionState == ChatSessionState.AI_SPEAKING) {
        updateStatusText("可以随时说话打断我");
    }
}
```
</Tab>
<Tab title="cmd 为 3">
对于 cmd 为 3, 相同的 message_id 取 seq_id 最大的消息进行覆盖，只显示 seq_id 最大的 message 的文本：
```java
public void updateASRChatMessage(AudioChatTextMessage newMessage) {
    Optional<AudioChatTextMessage> findMessage = rtcMessageList.stream()
        .filter(rtcRoomMessage -> rtcRoomMessage.data.message_id.equals(newMessage.data.message_id)).findAny();
    if (findMessage.isPresent()) {
        AudioChatTextMessage existedMessage = findMessage.get();
        if (existedMessage.seq_id < newMessage.seq_id) {
            log.d("本地seq_id 比较小，更新消息 = [" + newMessage + "]");
            existedMessage.seq_id = newMessage.seq_id;
            existedMessage.timestamp = newMessage.timestamp;
            existedMessage.round = newMessage.round;
            existedMessage.data = newMessage.data;
            notifyDataSetChanged();
        } else {
            log.d("本地seq_id 比较大，不用更新 = [" + newMessage + "]");
        }
    } else {
        log.d("新消息，直接插入 = [" + newMessage + "]");
        rtcMessageList.add(newMessage);
        notifyDataSetChanged();
    }
}
```

</Tab>
<Tab title="cmd 为 4">
对于 cmd 为 4, 相同的 message_id 按照 seq_id 进行排序，然后合并文本进行显示。
```java
/**
 * 消息列表的所有数据
 */
private List<AudioChatTextMessage> rtcMessageList = new ArrayList<>();

/**
 * LLM消息缓存
 */
private Map<String, List<AudioChatTextMessage>> llmMessageTemp = new HashMap<>();
/**
 * LLM消息时间记录
 */
private Map<String, Long> messageTimes = new HashMap<>();

public void addOrUpdateLLMChatMessage(AudioChatTextMessage newMessage) {
      List<AudioChatTextMessage> rtcRoomMessages = llmMessageTemp.get(newMessage.data.message_id);
      if (rtcRoomMessages == null) {
          log.d("缓存列表为空，创建列表并且添加 message:" + newMessage.data + ",添加之前有：" + llmMessageTemp.size()
              + "个缓存列表");
          rtcRoomMessages = new ArrayList<>();
          rtcRoomMessages.add(newMessage);
          llmMessageTemp.put(newMessage.data.message_id, rtcRoomMessages);
      } else {
          log.d("缓存列表有数据，直接添加 message: " + newMessage.data + ",目前有：" + llmMessageTemp.size() + "个缓存列表");
          rtcRoomMessages.add(newMessage);
      }

      if (rtcRoomMessages.size() > 1) {
          rtcRoomMessages.sort(new Comparator<AudioChatTextMessage>() {
              @Override
              public int compare(AudioChatTextMessage o1, AudioChatTextMessage o2) {
                  return o1.seq_id - o2.seq_id;
              }
          });
      }

      StringBuilder builder = new StringBuilder();
      for (int i = 0; i < rtcRoomMessages.size(); i++) {
          builder.append(rtcRoomMessages.get(i).data.text);
      }

      String string = builder.toString();
      if (!TextUtils.isEmpty(string)) {
          Optional<AudioChatTextMessage> any = rtcMessageList.stream()
              .filter(roomMessage -> roomMessage.data.message_id.equals(newMessage.data.message_id)).findAny();
          if (any.isPresent()) {
              any.get().data.text = string;
              log.d("更新文本 ： [" + string + "]");
          } else {
              AudioChatTextMessage generateMessage = new AudioChatTextMessage();
              generateMessage.timestamp = newMessage.timestamp;
              generateMessage.seq_id = newMessage.seq_id;
              generateMessage.round = newMessage.round;
              generateMessage.cmd = newMessage.cmd;
              generateMessage.data = new Data();
              generateMessage.data.speak_status = newMessage.data.speak_status;
              generateMessage.data.text = string;
              generateMessage.data.message_id = newMessage.data.message_id;
              generateMessage.data.end_flag = newMessage.data.end_flag;
              rtcMessageList.add(generateMessage);
              log.d("插入文本 ： [" + string + "]");
          }
      }

      // 来了新消息，按照 <messageID,当前时间> 存入 map
      messageTimes.put(newMessage.data.message_id, System.currentTimeMillis());

      Iterator<Entry<String, Long>> iterator = messageTimes.entrySet().iterator();
      while (iterator.hasNext()) {
          Map.Entry<String, Long> entry = iterator.next();
          String messageID = entry.getKey();
          long lastTime = entry.getValue();
          long current = System.currentTimeMillis();
          // 遍历整个map检查每一个messageID,如果超过 4 秒还没有更新，删除对应的缓存消息列表
          if (current - lastTime >= 4000) {
              llmMessageTemp.remove(messageID);
              log.d(
                  " 清除 message_id :" + messageID + " 缓存列表，目前还有" + llmMessageTemp.size() + "个缓存列表");
              iterator.remove();
          }
      }

      notifyDataSetChanged();
  }
```

</Tab>
</Tabs>
