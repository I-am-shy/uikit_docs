---
articleID: 7633
---
# 实现视频通话

---


@@@Common_usage_introduction@@@

## 2 前提条件

在实现基本的实时音视频功能之前，请确保：

@@@Express_Video_Implementation_Process_Prerequisites@@@


## 3 实现流程


@@@quick_start_base_intro@@@

<h1 id="CreateEngine"> </h1>

### 3.1 创建引擎

**1. 创建界面**

根据场景需要，为您的项目创建视频通话的用户界面。我们推荐您在项目中添加如下元素：

- 本地视频窗口
- 远端视频窗口
- 结束通话按钮

![/Pics/QuickStart/express_quickstart_video_call.png](http://doc.oa.zego.im/Pics/QuickStart/express_quickstart_video_call_pc.png)

**2. 引入头文件**

在项目中引入 ZegoExpressEngine 头文件。

```C++
// 引入 ZegoExpressEngine.h 头文件
#include "ZegoExpressSDK.h"
```

**3. 创建引擎**

调用 [createEngine ](@createEngine) 接口，将申请到的 AppID 和 AppSign 传入参数 “appID” 和 “appSign”。

根据 App 实际的音视频业务选择一个合适的场景，请参考 [场景化音视频配置](!video_proflie) 文档，把选择好的场景枚举传入参数 "scenario"。


<div class="mk-warning">

SDK 同时也支持 Token 鉴权，若您对项目安全性有更高要求，建议您升级鉴权方式，可参考 [如何从 AppSign 鉴权升级为 Token 鉴权](http://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo)。
</div>


```C++
ZegoEngineProfile profile;
// AppID 和 AppSign 由 ZEGO 分配给各 App；其中，为了安全考虑，建议将 AppSign 存储在 App 的业务后台，需要使用时从后台获取
profile.appID = appID;
profile.appSign = appSign;
// 指定使用直播场景 (请根据实际情况填写适合你业务的场景)
profile.scenario = ZegoScenario::ZEGO_SCENARIO_BROADCAST;
// 创建引擎实例
auto engine = ZegoExpressSDK::createEngine(profile, nullptr);
```


**4. 设置回调**

您可以通过实例化实现 [IZegoEventHandler](@-IZegoEventHandler) 接口的类并实现需要的回调方法，以监听并处理所关注的事件回调，然后将实例化对象作为`eventHandler`参数传递给 [createEngine ](@createEngine) 方法或者传递给 [setEventHandler](/article/api?doc=Express_Video_SDK_API~cpp_windows~class~IZegoExpressEngine#set-event-handler) 注册回调。


<div class="mk-warning">

 建议在创建引擎时或创建引擎后就立即注册回调，避免延后注册错过事件通知。
</div>

<details class="zg-primary">
  <summary>常见通知回调</summary>

**我在房间内的连接状态变化通知**

[onRoomStateChanged](@onRoomStateChanged): 本地调用 [loginRoom](@loginRoom) 加入房间时，您可通过监听 [onRoomStateChanged](@onRoomStateChanged) 回调实时监控自己在本房间内的连接状态。

您可以在回调中根据不同状态处理业务逻辑。

```C++
virtual void onRoomStateChanged(const std::string& roomID, ZegoRoomStateChangedReason reason, int errorCode, const std::string& extendedData) {

}
```

ZegoRoomStateChangedReason 状态含义如下：

<table>
  <colgroup>
    <col width="30%">
    <col width="20%">
    <col width="50%">
  </colgroup>
  <tbody><tr>
    <th>状态</th>
    <th>枚举值</th>
    <th>含义</th>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_LOGINING</td>
    <td>0</td>
    <td>正在登录房间。当调用 [loginRoom] 登录房间或 [switchRoom] 切换到目标房间时，进入该状态，表示正在请求连接服务器。通常通过该状态进行应用界面的展示。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_LOGINED</td>
    <td>1</td>
    <td>登录房间成功。当登录房间或切换房间成功后，进入该状态，表示登录房间已经成功，用户可以正常收到房间内的其他用户和所有流信息增删的回调通知。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_LOGIN_FAILED</td>
    <td>2</td>
    <td>登录房间失败。当登录房间或切换房间失败后，进入该状态，表示登录房间或切换房间已经失败，例如 AppID 或 Token 不正确等。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECTING</td>
    <td>3</td>
    <td>房间连接临时中断。如果因为网络质量不佳产生的中断，SDK 会进行内部重试。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECTED</td>
    <td>4</td>
    <td>房间重新连接成功。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连成功后进入该状态。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECT_FAILED</td>
    <td>5</td>
    <td>房间重新连接失败。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连失败后进入该状态。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_KICK_OUT</td>
    <td>6</td>
    <td>被服务器踢出房间。例如有相同用户名在其他地方登录房间导致本端被踢出房间，会进入该状态。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_LOGOUT</td>
    <td>7</td>
    <td>登出房间成功。没有登录房间前默认为该状态，当调用 [logoutRoom] 登出房间成功或 [switchRoom] 内部登出当前房间成功后，进入该状态。</td>
  </tr>
  <tr>
    <td>ZEGO_ROOM_STATE_CHANGED_REASON_LOGOUT_FAILED</td>
    <td>8</td>
    <td>登出房间失败。当调用 [logoutRoom] 登出房间失败或 [switchRoom] 内部登出当前房间失败后，进入该状态。</td>
  </tr>
</tbody></table>


**其他用户进出房间的通知**

[onRoomUserUpdate](@onRoomUserUpdate): 同一房间内的其他用户进出房间时，您可通过此回调收到通知。

<div class="mk-warning">

- 只有在登录房间 [loginRoom](@loginRoom) 时传的配置 [ZegoRoomConfig](@ZegoRoomConfig) 中的 isUserStatusNotify 参数为 true 时，用户才能收到房间内其他用户的回调。

- 回调中的参数 [ZegoUpdateType](@-ZegoUpdateType) 为 ZEGO_UPDATE_TYPE_ADD 时，表示有用户进入了房间；[ZegoUpdateType](@-ZegoUpdateType) 为 ZEGO_UPDATE_TYPE_DELETE 时，表示有用户退出了房间。
</div>

```C++
void VideoTalk::onRoomUserUpdate(const std::string &roomID, ZegoUpdateType updateType, const std::vector<ZegoUser> &userList) {
    // 您可以在回调中根据用户的进出/退出情况，处理对应的业务逻辑
    if (updateType == ZEGO_UPDATE_TYPE_ADD) {

    } else if (updateType == ZEGO_UPDATE_TYPE_DELETE) {

    }
}
```

**用户推送音视频流的状态通知**

[onPublisherStateUpdate](@onPublisherStateUpdate)：根据实际应用需要，用户推送音视频流之后，当推送视频流的状态发生变更时（如出现网络中断导致推流异常等情况），您会收到该回调，同时 SDK 会自动进行重试。

```C++
void VideoTalk::onPublisherStateUpdate(const std::string &streamID, ZegoPublisherState state, int errorCode, const std::string &extendData) {
    if (errorCode != 0) {
        // 推流状态出错
    } else {
        switch (state) {
            case ZEGO_PUBLISHER_STATE_PUBLISHING:
                // 正在推流
                break;
            case ZEGO_PUBLISHER_STATE_PUBLISH_REQUESTING:
                // 正在请求推流
                break;
            case ZEGO_PUBLISHER_STATE_NO_PUBLISH:
                // 没有推流
                break;
        }
    }
}
```

**用户拉取音视频流的状态通知**

[onPlayerStateUpdate](@onPlayerStateUpdate)：根据实际应用需要，用户拉取音视频流之后，当拉取视频流的状态发生变更时（如出现网络中断导致拉流异常等情况），您会收到该回调，同时 SDK 会自动进行重试。

```C++
void VideoTalk::onPlayerStateUpdate(const std::string &streamID, ZegoPlayerState state, int errorCode, const std::string &extendData) {
    if (errorCode != 0) {
        //拉流状态出错
    } else {
        switch (state) {
            case ZEGO_PLAYER_STATE_NO_PLAY:
                // 正在拉流中
                break;
            case ZEGO_PLAYER_STATE_PLAY_REQUESTING:
                // 正在请求拉流中
                break;
            case ZEGO_PLAYER_STATE_NO_PLAY:
                // 未进行拉流
                break;
        }
    }
}
```
</details>


<a id="createroom"></a>

### 3.2 登录房间

传入用户 ID 参数 “userID” 创建 [ZegoUser ](@ZegoUser) 用户对象后，调用 [loginRoom ](@loginRoom) 接口，传入房间 ID 参数 “roomID” 和用户参数 “user”，登录房间。如果房间不存在，调用该接口时会创建并登录此房间。

roomID 和 user 的参数由您本地生成，但是需要满足以下条件：

- 同一个 AppID 内，需保证 “roomID” 全局唯一。
- 同一个 AppID 内，需保证 “userID” 全局唯一，建议开发者将其设置成一个有意义的值，可将 “userID” 与自己业务账号系统进行关联。

<div class="mk-warning">

[ZegoUser ](@ZegoUser) 不能为默认值，否则会导致登录房间失败。

</div>

```C++
// 创建用户对象
ZegoUser user("user1", "user1");
// 只有传入 “isUserStatusNotify” 参数取值为 “true” 的 ZegoRoomConfig，才能收到 onRoomUserUpdate 回调。
ZegoRoomConfig roomConfig;
//如果您使用 appsign 的方式鉴权，token 参数不需填写；如果需要使用更加安全的 鉴权方式： token 鉴权，请参考[如何从 AppSign 鉴权升级为 Token 鉴权](https://doc-zh.zego.im/faq/token_upgrade?product=ExpressVideo&platform=all)
// roomConfig.token = "xxxx";
roomConfig.isUserStatusNotify = true;
// 登录房间
engine->loginRoom(roomID, user, roomConfig, [=](){
    // (可选回调) 登录房间结果，如果仅关注登录结果，关注此回调即可
});
```

调用登录房间接口之后，您可通过监听 [onRoomStateChanged](@onRoomStateChanged) 回调实时监控自己在本房间内的连接状态。

仅当房间状态是登录成功或重连成功时，推流（[startPublishingStream](@startPublishingStream)）、拉流（[startPlayingStream](@startPlayingStream)）才能正常收发音视频。

```C++
void onRoomStateChanged(const std::string &roomID, ZegoRoomStateChangedReason reason, int errorCode, const std::string &extendedData) {
    if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_LOGINING)
    {
        // 登录中
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_LOGINED)
    {
        // 登录成功
        //只有当房间状态是登录成功或重连成功时，推流（startPublishingStream）、拉流（startPlayingStream）才能正常收发音视频
        //将自己的音视频流推送到 ZEGO 音视频云
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_LOGIN_FAILED)
    {
        // 登录失败
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECTING)
    {
        // 重连中
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECTED)
    {
        // 重连成功
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_RECONNECT_FAILED)
    {
        // 重连失败
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_KICK_OUT)
    {
        // 被踢出房间
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_LOGOUT)
    {
        // 登出成功
    }
    else if(reason == ZEGO_ROOM_STATE_CHANGED_REASON_LOGOUT_FAILED)
    {
        // 登出失败
    }
}
```
<a id="publishingStream"></a>

### 3.3 预览自己的画面，并推送到 ZEGO 音视频云

**1. （可选）预览自己的画面**

<div class="mk-hint">

无论是否调用 [startPreview ](@startPreview) 预览，都可以将自己的音视频流推送到 ZEGO 音视频云。
</div>


设置预览视图并启动本地预览。

如果希望看到本端的画面，可调用 [startPreview ](@startPreview) 接口设置预览视图，并启动本地预览。

```C++
// 设置本地预览视图并启动预览，视图模式采用 SDK 默认的模式，等比缩放填充整个 View
ZegoCanvas canvas((void*)view);
engine->startPreview(&canvas);
```

**2. 将自己的音视频流推送到 ZEGO 音视频云**

在用户调用 [loginRoom ](@loginRoom) 接口后，可以直接调用 [startPublishingStream ](@startPublishingStream) 接口，传入 streamID，将自己的音视频流推送到 ZEGO 音视频云。您可通过监听 [onPublisherStateUpdate ](@onPublisherStateUpdate) 回调知晓推流是否成功。

streamID 由您本地生成，但是需要保证：
同一个 AppID 下，“streamID” 全局唯一。如果同一个 AppID 下，不同用户各推了一条 “streamID” 相同的流，会导致后推流的用户推流失败。

此处示例在调用 [loginRoom ](@loginRoom) 接口后立即进行推流。在实现具体业务时，您可选择其他时机进行推流，只要保证先调用 [loginRoom ](@loginRoom) 即可。

```C++
// 用户调用 loginRoom 之后再调用此接口进行推流
// 在同一个 AppID 下，开发者需要保证“streamID” 全局唯一，如果不同用户各推了一条 “streamID” 相同的流，后推流的用户会推流失败。
engine->startPublishingStream("stream1");
```

@@@Warning_How_to_switch_devices@@@

<a id="PlayingStream"></a>

### 3.4 拉取其他用户的音视频

进行视频通话时，我们需要拉取到其他用户的音视频。

[onRoomStreamUpdate](@onRoomStreamUpdate)：在同一房间内的其他用户将音视频流推送到 ZEGO 音视频云时，我们会在此回调中收到音视频流新增的通知。

我们可以在该回调中，调用 [startPlayingStream](@startPlayingStream)，传入 “streamID” 拉取播放该用户的音视频。

<div class="mk-warning">

如果用户在音视频通话的过程中，遇到相关错误，可查询 [错误码](!Error_Code/Error_Code)。
</div>

```C++
// 房间内其他用户推流/停止推流时，我们会在这里收到相应流增减的通知
void VideoTalk::onRoomStreamUpdate(const std::string &roomID, ZegoUpdateType updateType, const std::vector<ZegoStream> &streamList, const std::string &extendData) {
    //当 updateType 为 ZEGO_UPDATE_TYPE_ADD 时，代表有音视频流新增，此时我们可以调用 startPlayingStream 接口拉取播放该音视频流
    if (updateType == ZEGO_UPDATE_TYPE_ADD) {
        // 开始拉流，设置远端拉流渲染视图，视图模式采用 SDK 默认的模式，等比缩放填充整个 View
        // 如下 playView 为 UI 窗口句柄
        std::string streamID = streamList[0].streamID;
        ZegoCanvas canvas((void*)playView);
        engine->startPlayingStream(streamID , &canvas);
    }
}

```

### 3.5 在线测试推拉流功能

@@@New_Experience_RTC_Functions@@@

### 3.6 停止音视频通话

<a id="stopPublishingStream"></a>

#### 3.6.1 停止推送和拉取音视频流

**1. 停止推流，停止预览**

调用 [stopPublishingStream ](@stopPublishingStream) 接口停止向远端用户发送本端的音视频流。

```C++
// 停止推流
engine->stopPublishingStream();
```

如果启用了本地预览，调用 [stopPreview ](@stopPreview) 接口停止预览。

```C++
// 停止本地预览
engine->stopPreview();
```

**2. 停止拉流**

调用 [stopPlayingStream ](@stopPlayingStream) 接口停止拉取远端推送的音视频流。

@@@Express_stopPlayingStream_time@@@

```C++
// 停止拉流
engine->stopPlayingStream("stream1");
```

#### 3.6.2 退出房间

调用 [logoutRoom ](@logoutRoom) 接口退出房间。

```C++
// 退出房间
engine->logoutRoom("room1");
```

#### 3.6.3 销毁引擎

如果用户彻底不使用音视频功能时，可调用 [destroyEngine ](@destroyEngine) 接口销毁引擎，释放麦克风、摄像头、内存、CPU 等资源。

- 如果需要监听回调，来确保设备硬件资源释放完成，可在销毁引擎时传入 “callback”。该回调只用于发送通知，开发者不可以在回调内释放与引擎相关的资源。

- 如果不需要监听回调，可传入 “nullptr”。

```C++
ZegoExpressSDK::destroyEngine(engine, nullptr);
engine = nullptr;

```

## 4 视频通话 API 调用时序

<img src="/Pics/QuickStart/quickstart_uml.png" alt="时序图">

## 5 常见问题

##### 1. 调用 [logoutRoom](@logoutRoom) 登出房间时能否直接杀掉进程？
调用 [logoutRoom](@logoutRoom) 后直接杀掉进程，有一定概率会导致 [logoutRoom](@logoutRoom) 信令没发出去，那么 ZEGO 服务端只能等心跳超时后才认为这个用户退出了房间，为了确保 [logoutRoom](@logoutRoom) 信令发送出去，建议再调用 [destroyEngine](@destroyEngine) 并收到回调后再杀进程。

@@@relevant_quickstart@@@
