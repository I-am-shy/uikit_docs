---
articleID: 17570
---
# 播放透明礼物特效

- - -
## 功能简介

@@@gift_special_effects_info@@@


## 示例源码


请参考 [下载示例源码](!DownloadDemo/DownloadDemo) 获取源码。

相关源码请查看 “/ZegoExpressExample/Examples/Others/MediaPlayer” 目录下的文件。


## 前提条件

在使用媒体播放器播放 MP4 动态效果，即实现播放透明礼物特效之前，请确保：

@@@Express-Video_Prerequisites@@@



## 实现流程

### 1 输出素材

@@@Express_gift_special_effects_step1@@@
  

### 2 创建媒体播放器

调用 [createMediaPlayer](@createMediaPlayer) 创建媒体播放器，并调用 [setPlayerCanvas](@setPlayerCanvas-IZegoMediaPlayer) 设置播放器 canvas 的 `alphaBlend` 属性为 `true`。

```C++
ZegoCanvas canvas(mediaPlayerView);//mediaPlayerView 为媒体播放器 view
canvas.alphaBlend = true;//支持 Alpha 通道渲染
mediaPlayer->setPlayerCanvas(&canvas);
```

### 3 加载素材

调用 [createMediaPlayer](@createMediaPlayer) 创建媒体播放器后，通过 [loadResourceWithConfig](@loadResourceWithConfig-ZegoMediaPlayer) 接口，通过**文件路径**或**二进制内存数据**，播放拼接后的特效素材。

<div class="mk-warning">

虽然 [loadResourceWithConfig](@loadResourceWithConfig-ZegoMediaPlayer) 接口支持通过版权音乐资源 ID 加载多媒体资源，但是版权音乐目前不支持视频，因此无法通过版权音乐资源 ID 加载方式来加载礼物特效。
</div>

<div class="multiple-select-codes">
    <div class="code-tabs hide-scrollbar">
      <div class="scroll-box">
        <span class="tab-item">
          <span>通过文件路径加载</span>
        </span>
        <span class="tab-item">
          <span>通过二进制内存数据加载</span>
        </span>
      </div>
    </div>

  <div class="code-list">
  
  ```C++
  ZegoMediaPlayerResource resource;
  resource.loadType = ZEGO_MULTIMEDIA_LOAD_TYPE_MEMORY;//加载方式选择文件路径加载
  resource.filePath = "filePath";//文件路径
  resource.alphaLayout = ZEGO_ALPHA_LAYOUT_TYPE_LEFT;//根据实际资源选择 Alpha 通道布局
  mediaPlayer->loadResourceWithConfig(resource, [=](int errorCode){
      //资源加载结果
      // 可执行更新 UI 等逻辑
      if (errorCode == 0) {
          //加载文件成功，此时可以开始播放媒体资源
          mediaPlayer->start();
      }
  });
  ```

  ```C++
  // 加载资源文件并返回二进制数据
  unsigned char* ZegoUtilHelper::LoadResourceFile(const QString& filePath, int& dataSize)
  {
      // 加载资源文件
      QResource resource(filePath);
      if (!resource.isValid()) {
          return nullptr;
      }

      // 读取资源数据
      QByteArray data;
      if(resource.isCompressed()){
          data = resource.uncompressedData();
      }else{
          int dataSize = resource.size();
          data = {(char *)resource.data(), dataSize};
      }

      // 分配内存并复制数据
      unsigned char* buffer = new unsigned char[data.size()];
      std::memcpy(buffer, data.constData(), data.size());

      // 更新数据大小
      dataSize = data.size();

      return buffer;
  }

  ZegoMediaPlayerResource resource;
  resource.loadType = ZEGO_MULTIMEDIA_LOAD_TYPE_FILE_PATH;//加载方式选择二进制内存数据加载
  resource.alphaLayout = ZEGO_ALPHA_LAYOUT_TYPE_LEFT;//根据实际资源选择 Alpha 通道布局

  QString resourcePath = ":/media/Resources/Alpha/alpha_left/source1_complex_rl.mp4";
  int dataSize = 0;
  unsigned char *memPtr = ZegoUtilHelper::LoadResourceFile(resourcePath, dataSize);
  if(memPtr != nullptr && dataSize != 0){
      resource.memory = memPtr;
      resource.memoryLength = dataSize;
  }

  mediaPlayer->loadResourceWithConfig(resource, [=](int errorCode){
      //资源加载结果
      // 可执行更新 UI 等逻辑
      if (errorCode == 0) {
          //加载文件成功，此时可以开始播放媒体资源
          mediaPlayer->start();
      }
  });

  // 释放内存
  if(memPtr != nullptr){
      delete[] memPtr;
  }
  ```
  
  </div>
</div>

### 4 播放素材

在调用 [loadResourceWithConfig](@loadResourceWithConfig-IZegoMediaPlayer) 加载文件成功后，可调用 [start](@start-IZegoMediaPlayer)、[pause](@pause-IZegoMediaPlayer)、[resume](@resume-IZegoMediaPlayer)、[stop](@stop-IZegoMediaPlayer) 来启停播放。一旦播放器的内部状态改变，[IZegoMediaPlayer](@-IZegoMediaPlayer) 的 [onMediaPlayerStateUpdate](@onMediaPlayerStateUpdate-IZegoMediaPlayerEventHandler) 回调将会被触发。

开发者也可通过调用 [getCurrentState](@getCurrentState-IZegoMediaPlayer) 随时获取播放器的当前状态。

如果 [enableRepeat](@enableRepeat-IZegoMediaPlayer) 设置为 `true`，则播放器会在播放完文件后自动重播。

```C++
// 开始播放，播放之前需要先调用接口加载媒体文件
mediaPlayer->start();
// 暂停
mediaPlayer->pause();
// 恢复
mediaPlayer->resume();
// 停止
mediaPlayer->stop();
```
