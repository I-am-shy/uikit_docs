# 快速实现超低延迟直播

---


@@@Common_usage_introduction_live@@@

## 2 前提条件

在实现超低延迟直播功能之前，请确保：

@@@Prerequisites_for_Live_Streaming@@@


## 3 实现流程

@@@quick_start_base_intro_live@@@


### 3.1 开通服务

@@@Open_Live_Streaming@@@

### 3.2 初始化

**1. 创建界面**

根据场景需要，为您的项目创建直播的用户界面。我们推荐您在项目中添加如下元素：

- 本地视频窗口
- 远端视频窗口
- 退出直播按钮

<div class="mk-hint">

- 当本地用户为主播时，才会显示本地视频窗口，即若本地用户为观众，仅显示远端视频窗口。
- 当远端用户为主播时，才会显示远端视频窗口。
</div>

<img src="/Pics/QuickStart/express_quickstart_video_call_new.png" width="50%">

**2. 导入 ZegoExpressEngine**

在项目中导入 ZegoExpressEngine。

```swift
import ZegoExpressEngine
```


**3. 创建引擎**

调用创建引擎接口，将申请到的 AppID 传入参数 “appID”，创建引擎单例对象。


```swift
let profile = ZegoEngineProfile()
// 请通过官网注册获取，格式为：1234567890
profile.appID = <#appID#>
// 指定使用直播场景 (请根据实际情况填写适合你业务的场景)
profile.scenario = .default
// 创建引擎，并注册 self 为 eventHandler 回调。不需要注册回调的话，eventHandler 参数可以传 nil，后续可调用 "setEventHandler:" 方法设置回调
ZegoExpressEngine.createEngine(with: profile, eventHandler: self)
```

**4. 设置回调**

您可以通过实现 [ZegoEventHandler\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler) 接口的类并实现需要的回调方法，以监听并处理所关注的事件回调。然后将实例化对象作为`eventHandler`参数传递给 `createEngine` 或者传递给 [setEventHandler\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#set-event-handler)  注册回调。


<div class="mk-warning">

建议在创建引擎时或创建引擎后就立即注册回调，避免延后注册错过事件通知。
</div>


<details class="zg-primary">
    <summary>常见通知回调</summary>

**1. 我在房间内的连接状态变化通知**

[onRoomStateChanged\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-state-changed-error-code-extended-data-room-id): 本地调用 [loginRoom\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 加入房间时，您可通过监听 [onRoomStateChanged\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-state-changed-error-code-extended-data-room-id) 回调实时监控自己在本房间内的连接状态。

您可以在回调中根据不同状态处理业务逻辑。

```swift
func onRoomStateChanged(_ reason: ZegoRoomStateChangedReason, errorCode: Int32, extendedData: [AnyHashable : Any], roomID: String) {

}
```

ZegoRoomStateChangedReason 状态含义如下，更多信息请参考 [房间状态管理\|_blank](#14773)：


<table>
  <colgroup>
    <col width="30%">
    <col width="20%">
    <col width="50%">
  </colgroup>
  <tbody><tr>
    <th>状态</th>
    <th>枚举值</th>
    <th>含义</th>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonLogining</td>
    <td>0</td>
    <td>正在登录房间。当调用 [loginRoom] 登录房间或 [switchRoom] 切换到目标房间时，进入该状态，表示正在请求连接服务器。通常通过该状态进行应用界面的展示。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonLogined</td>
    <td>1</td>
    <td>登录房间成功。当登录房间或切换房间成功后，进入该状态，表示登录房间已经成功，用户可以正常收到房间内的其他用户和所有流信息增删的回调通知。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonLoginFailed</td>
    <td>2</td>
    <td>登录房间失败。当登录房间或切换房间失败后，进入该状态，表示登录房间或切换房间已经失败，例如 AppID 或 Token 不正确等。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonReconnecting</td>
    <td>3</td>
    <td>房间连接临时中断。如果因为网络质量不佳产生的中断，SDK 会进行内部重试。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonReconnected</td>
    <td>4</td>
    <td>房间重新连接成功。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连成功后进入该状态。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonReconnectFailed</td>
    <td>5</td>
    <td>房间重新连接失败。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连失败后进入该状态。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonKickOut</td>
    <td>6</td>
    <td>被服务器踢出房间。例如有相同用户名在其他地方登录房间导致本端被踢出房间，会进入该状态。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonLogout</td>
    <td>7</td>
    <td>登出房间成功。没有登录房间前默认为该状态，当调用 [logoutRoom] 登出房间成功或 [switchRoom] 内部登出当前房间成功后，进入该状态。</td>
  </tr>
  <tr>
    <td>ZegoRoomStateChangedReasonLogoutFailed</td>
    <td>8</td>
    <td>登出房间失败。当调用 [logoutRoom] 登出房间失败或 [switchRoom] 内部登出当前房间失败后，进入该状态。</td>
  </tr>
</tbody></table>



**2. 其他用户进出房间的通知**

[onRoomUserUpdate \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-user-update-user-list-room-id): 同一房间内的其他用户进出房间时，您可通过此回调收到通知。回调中的参数 [ZegoUpdateType \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~enum~ZegoUpdateType#zego-update-type-add) 为 ZegoUpdateTypeAdd 时，表示有用户进入了房间；[ZegoUpdateType \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~enum~ZegoUpdateType#zego-update-type-add) 为 ZegoUpdateTypeDelete 时，表示有用户退出了房间。

<div class="mk-warning">

- 只有在登录房间 [loginRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 时传的配置 [ZegoRoomConfig \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoRoomConfig) 中的 [isUserStatusNotify \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoRoomConfig#is-user-status-notify) 参数为 true 时，用户才能收到房间内其他用户的回调。
- 房间人数大于 500 人的情况下 `onRoomUserUpdate` 回调不保证有效。若业务场景存在房间人数大于 500 的情况，请联系 ZEGO 技术支持。

</div>

```swift
//同一房间内的其他用户进出房间时，您可通过此回调收到通知。回调中的参数 ZegoUpdateType 为 ZegoUpdateTypeAdd 时，表示有用户进入了房间；ZegoUpdateType 为 ZegoUpdateTypeDelete 时，表示有用户退出了房间。
// 只有在登录房间 loginRoom 时传的配置 ZegoRoomConfig 中的 isUserStatusNotify 参数为 YES 时，用户才能收到房间内其他用户的回调。
// 房间人数大于 500 人的情况下 onRoomUserUpdate 回调不保证有效。若业务场景存在房间人数大于 500 的情况，请联系 ZEGO 技术支持。
func onRoomUserUpdate(_ updateType: ZegoUpdateType, userList: [ZegoUser], roomID: String) {
    if updateType == .add {
        for user in userList {
            NSLog("用户%@进入了房间 %@", user.userName, roomID)
        }
    } else if updateType == .delete {
        for user in userList {
            NSLog("用户%@退出了房间 %@", user.userName, roomID)
        }
    }
}
```

**3. 用户推送音视频流的状态通知**

[onPublisherStateUpdate\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-publisher-state-update-error-code-extended-data-stream-id)：根据实际应用需要，用户推送音视频流之后，当推送视频流的状态发生变更时（如出现网络中断导致推流异常等情况），您会收到该回调，同时 SDK 会进行自动进行重试。

```swift
//用户推送音视频流的状态通知
//用户推送音视频流的状态发生变更时，会收到该回调。如果网络中断导致推流异常，SDK 在重试推流的同时也会通知状态变化。
func onPublisherStateUpdate(_ state: ZegoPublisherState, errorCode: Int32, extendedData: [AnyHashable : Any]?, streamID: String) {
    if errorCode != 0 {
        NSLog("推流状态出错 errorCode: %d", errorCode)
    } else {
        switch (state) {
        case .publishing:
            NSLog("正在推流")
            break
        case .publishRequesting:
            NSLog("正在请求推流")
            break
        case .noPublish:
            NSLog("没有推流")
            break
    }
}
```

**4. 用户拉取音视频流的状态通知**

[onPlayerStateUpdate\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-player-state-update-error-code-extended-data-stream-id)：根据实际应用需要，用户拉取音视频流之后，当拉取视频流的状态发生变更时（如出现网络中断导致拉流异常等情况），您会收到该回调，同时 SDK 会进行自动进行重试。

```swift
//用户拉取音视频流的状态通知
//用户拉取音视频流的状态发生变更时，会收到该回调。如果网络中断导致拉流异常，SDK 会自动进行重试。
func onPlayerStateUpdate(_ state: ZegoPlayerState, errorCode: Int32, extendedData: [AnyHashable : Any]?, streamID: String) {
    if (errorCode != 0) {
        NSLog("拉流状态出错 streamID: %@, errorCode:%d", streamID, errorCode)
    } else {
        switch (state) {
        case .playing:
            NSLog("正在拉流中")
            break
        case .playRequesting:
            NSLog("正在请求拉流中")
            break
        case .noPlay:
            NSLog("未进行拉流")
            break
        }
    }
}
```
</details>

<a id="createroom"></a>

### 3.3 登录房间


您可以调用 [loginRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 接口登录房间。如果房间不存在，调用该接口时会创建并登录此房间。roomID 和 user 的参数由您本地生成，但是需要满足以下条件：

- 同一个 AppID 内，需保证 “roomID” 全局唯一。  
- 同一个 AppID 内，需保证 “userID” 全局唯一，建议开发者将 “userID” 与自己业务的账号系统进行关联。 

```swift
// roomID 由您本地生成,需保证 “roomID” 全局唯一。不同用户要登录同一个房间才能进行通话
let roomID = "room1"

// 创建用户对象，ZegoUser 的构造方法 userWithUserID 会将 “userName” 设为与传的参数 “userID” 一样。“userID” 与 “userName” 不能为 “nil”，否则会导致登录房间失败。
// userID 由您本地生成,需保证 “userID” 全局唯一。
let user = ZegoUser(userID: "user1")

let config = ZegoRoomConfig()

// 只有传入 “isUserStatusNotify” 参数取值为 “true” 的 ZegoRoomConfig，才能收到 onRoomUserUpdate 回调。
config.isUserStatusNotify = true
//token 由用户自己的服务端生成，为了更快跑通流程，也可以通过 ZEGO 控制台获取临时的音视频 token
config.token = "<#token#>"

ZegoExpressEngine.shared().loginRoom(roomID, user: user, config: config) { errorCode, extendedData in
    // (可选回调) 登录房间结果，如果仅关注登录结果，关注此回调即可
    if (errorCode == 0) {
        NSLog("房间登录成功")
    } else {
        // 登录失败，请参考 errorCode 说明 https://doc-zh.zego.im/article/4377
        NSLog("房间登录失败")
    }
}
```

#### 登录状态（房间连接状态）回调

调用登录房间接口之后，您可通过监听 [onRoomStateChanged \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-state-changed-error-code-extended-data-room-id) 回调实时监控自己在本房间内的连接状态。

```swift
//本地调用 loginRoom 加入房间后，您可通过监听 onRoomStateChanged 回调实时监控自己在本房间内的连接状态。
//更多信息请参考 https://doc-zh.zego.im/article/12884
func onRoomStateChanged(_ reason: ZegoRoomStateChangedReason, errorCode: Int32, extendedData: [AnyHashable : Any], roomID: String) {
    if reason == .logining {
        // 正在登录房间。当调用 [loginRoom] 登录房间或 [switchRoom] 切换到目标房间时，进入该状态，表示正在请求连接服务器。通常通过该状态进行应用界面的展示。
    } else if reason == .logined {
        //登录房间成功。当登录房间或切换房间成功后，进入该状态，表示登录房间已经成功，用户可以正常收到房间内的其他用户和所有流信息增删的回调通知。
        //只有当房间状态是登录成功或重连成功时，推流（startPublishingStream）、拉流（startPlayingStream）才能正常收发音视频
    } else if reason == .loginFailed {
        //登录房间失败。当登录房间或切换房间失败后，进入该状态，表示登录房间或切换房间已经失败，例如 AppID 或 AppSign 不正确等。
    } else if reason == .reconnecting {
        //房间连接临时中断。如果因为网络质量不佳产生的中断，SDK 会进行内部重试。
    } else if reason == .reconnected {
        //房间重新连接成功。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连成功后进入该状态。
    } else if reason == .reconnectFailed {
        //房间重新连接失败。如果因为网络质量不佳产生的中断，SDK 会进行内部重试，重连失败后进入该状态。
    } else if reason == .kickOut {
        //被服务器踢出房间。例如有相同用户名在其他地方登录房间导致本端被踢出房间，会进入该状态。
    } else if reason == .logout {
        //登出房间成功。没有登录房间前默认为该状态，当调用 [logoutRoom] 登出房间成功或 [switchRoom] 内部登出当前房间成功后，进入该状态。
    } else if reason == .logoutFailed {
        //登出房间失败。当调用 [logoutRoom] 登出房间失败或 [switchRoom] 内部登出当前房间失败后，进入该状态。
    }
}
```

<a id="publishingStream"></a>


### 3.4 主播预览自己的画面，并推送到 ZEGO 音视频云

**1. （可选）主播预览自己的画面**

<div class="mk-hint">

无论是否调用 [startPreview \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#start-preview) 预览，都可以将自己的音视频流推送到 ZEGO 音视频云。
</div>

如果希望看到本端的画面，可调用 [startPreview\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#start-preview) 接口设置预览视图，并启动本地预览。

```swift
// 设置本地预览视图并启动预览，视图模式采用 SDK 默认的模式，等比缩放填充整个 View
let previewCanvas = ZegoCanvas(view: localUserViewObject.view.view)
ZegoExpressEngine.shared().startPreview(previewCanvas)
```

**2. 将自己的音视频流推送到 ZEGO 音视频云**

在用户调用 [loginRoom\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 接口后，可以直接调用 [startPublishingStream\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#start-publishing-stream) 接口，传入 “streamID”，将自己的音视频流推送到 ZEGO 音视频云。您可通过监听 [onPublisherStateUpdate\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-publisher-state-update-error-code-extended-data-stream-id) 回调知晓推流是否成功。

“streamID” 由您本地生成，但是需要保证：

同一个 AppID 下，“streamID” 全局唯一。如果同一个 AppID 下，不同用户各推了一条 “streamID” 相同的流，后推流的用户推流失败。 

此处示例在调用 [loginRoom\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 接口后立即进行推流。在实现具体业务时，您可选择其他时机进行推流，只要保证先调用 [loginRoom\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#login-room-user) 即可。

```swift
// 用户调用 loginRoom 之后再调用此接口进行推流
// 在同一个 AppID 下，开发者需要保证 “streamID” 全局唯一，如果不同用户各推了一条 “streamID” 相同的流，后推流的用户会推流失败。
ZegoExpressEngine.shared().startPublishingStream(localStreamID)
```

@@@Warning_How_to_switch_devices@@@

### 3.5 拉取主播的音视频

进行直播时，我们需要拉取到主播的音视频。通过超低延迟直播拉流的延迟，可控制在 1s 以内，更能实现超低延迟、超强同步、抗极端弱网、超低卡顿、超清画质、首帧秒开的流畅直播体验。

在同一房间内的其他用户将音视频流推送到 ZEGO 音视频云时，我们会在 [onRoomStreamUpdate\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-stream-update-stream-list-extended-data-room-id) 回调中收到音视频流新增的通知，并可以通过 ZegoStream 获取到某条流的 “streamID”。

我们可以在该回调中，调用 [startPlayingStream\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#start-playing-stream-canvas) ，传入 “streamID” 拉取拉取播放该用户的音视频。您可通过监听 [onPlayerStateUpdate |_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-player-state-update-error-code-extended-data-stream-id) 回调知晓是否成功拉取音视频。您可以选择如下拉流方式。

<div class="mk-warning">

- 超低延迟直播不是默认开启的，请在 ZEGO 控制台自助开通或联系 ZEGO 技术支持，详情请参考 [3.1 开通服务](#13415#3_1)。
- 如果用户在音视频直播的过程中，遇到相关错误，可查询 [错误码\|_blank](!Error_Code/Error_Code)。
</div>


调用 [startPlayingStream\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#start-playing-stream-canvas) 接口，并将 [resourceMode\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoPlayerConfig#resource-mode) 参数设置为 “ZegoStreamResourceModeOnlyL3”，表示超低延迟直播拉流。


```swift
// 房间内其他用户推流/停止推流时，我们会在这里收到相应流增减的通知
func onRoomStreamUpdate(_ updateType: ZegoUpdateType, streamList: [ZegoStream], extendedData: [AnyHashable: Any]?, roomID: String) {
    //当 updateType 为 ZegoUpdateTypeAdd 时，代表有音视频流新增，此时我们可以调用 startPlayingStream 接口拉取播放该音视频流
    if updateType == .add {
        // 开始拉流，设置远端拉流渲染视图，视图模式采用 SDK 默认的模式，等比缩放填充整个View
        // 如下 remoteUserView 为 UI 界面上 View.这里为了使示例代码更加简洁，我们只拉取新增的音视频流列表中第的第一条流，在实际的业务中，建议开发者循环遍历 streamList ，拉取每一条音视频流
        let streamID = streamList[0].streamID
        let playerConfig = ZegoPlayerConfig()
        playerConfig.resourceMode = .onlyL3
        ZegoExpressEngine.shared().startPlayingStream(streamID, canvas: ZegoCanvas(view: view: viewObject.view.view), config: playerConfig)
    }
}
```

### 3.6 调试超低延迟直播功能

在真机中运行项目，运行成功后，可以看到本端视频画面。

为方便体验，ZEGO 提供了一个 [Web 端调试示例 \|_blank](https://zegodev.gitee.io/zego-express-webrtc-sample/assistDev/index.html)，在该页面下，输入相同的 AppID、RoomID、Server 地址和 Token，即可加入同一房间与真机设备互通。当成功开直播时，可以听到远端的音频，看到远端的视频画面。

### 3.7 停止推送/拉取音视频流

**1. 停止推流，停止预览**

调用 [stopPublishingStream \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#stop-publishing-stream-1) 接口停止向远端用户发送本端的音视频流。

```swift
// 停止推流
ZegoExpressEngine.shared().stopPublishingStream()
```

如果启用了本地预览，调用 [stopPreview \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#stop-preview) 接口停止预览。

```swift
// 停止本地预览
ZegoExpressEngine.shared().stopPreview()
```

**2. 停止拉流**

调用 [stopPlayingStream \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#stop-playing-stream) 接口停止拉取远端推送的音视频流。

<div class="mk-warning">

如果开发者通过 [onRoomStreamUpdate\|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~protocol~ZegoEventHandler#on-room-stream-update-stream-list-extended-data-room-id) 回调收到了音视频流 “减少” 的通知，请及时调用 [stopPlayingStream \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#stop-playing-stream) 接口停止拉流，避免拉到空流、产生额外的成本；或者，开发者可以根据自己的业务需求，选择合适的时机，主动调用 [stopPlayingStream \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#stop-playing-stream) 接口停止拉流。
</div>

```swift
// 停止拉流
ZegoExpressEngine.shared().stopPlayingStream("stream1")
```

### 3.8 退出房间

调用 [logoutRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#logout-room) 接口退出房间。

```swift
// 退出房间
ZegoExpressEngine.shared().logoutRoom()
```

### 3.9 销毁引擎

如果用户彻底不使用音视频功能时，可销毁引擎，释放麦克风、摄像头、内存、CPU 等资源。

- 如果需要监听回调，来确保设备硬件资源释放完成，可在销毁引擎时传入 “callback”。该回调只用于发送通知，开发者不可以在回调内释放与引擎相关的资源。
- 如果不需要监听回调，可传入 “nil”。

```swift
ZegoExpressEngine.destroy(nil)
```

## 4 直播 API 调用时序

<img src="/Pics/QuickStart/quickstart_uml.png" alt="时序图">

## 5 常见问题

##### 1. 调用 [logoutRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#logout-room) 登出房间时能否直接杀掉进程？

调用 [logoutRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#logout-room) 后直接杀掉进程，有一定概率会导致 [logoutRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#logout-room) 信令没发出去，那么 ZEGO 服务端只能等心跳超时后才认为这个用户退出了房间，为了确保 [logoutRoom \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#logout-room) 信令发送出去，建议再调用 [destroyEngine \|_blank](/article/api?doc=Express_Video_SDK_API~objective-c_ios~class~ZegoExpressEngine#destroy-engine) 并收到回调后再杀进程。

@@@relevant_quickstart@@@
