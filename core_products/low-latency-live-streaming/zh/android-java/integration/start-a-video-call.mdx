---
articleID: 13395
---
# 快速实现超低延迟直播

---


@@@Common_usage_introduction_live@@@

## 2 前提条件

在实现基本的超低延迟直播功能之前，请确保：

@@@Prerequisites_for_Live_Streaming@@@

<a id="process"></a>

## 3 实现流程

@@@quick_start_base_intro_live@@@

### 3.1 开通服务

@@@Open_Live_Streaming@@@

<a id="initialization"> </a>

### 3.2 初始化

**1. 创建界面**

根据场景需要，为你的项目创建视频直播的用户界面。我们推荐你在项目中添加如下元素：

- 本地视频窗口
- 远端视频窗口
- 退出直播按钮

<div class="mk-hint">

- 当本地用户为主播时，才会显示本地视频窗口，即若本地用户为观众，仅显示远端视频窗口。
- 当远端用户为主播时，才会显示远端视频窗口。
</div>

<img src="/Pics/QuickStart/express_quickstart_video_call_new.png" width="50%">

<details class="zg-primary">
    <summary>界面代码示例</summary>

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Playing">

    <TextureView
        android:id="@+id/logView"
        android:layout_width="match_parent"
        android:layout_height="50dp"
        android:layout_alignParentTop="true"/>

    <TextureView
        android:id="@+id/previewView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/logView"
        android:layout_alignParentBottom="true"
        android:layout_alignParentLeft="true"/>

    <TextView
        android:id="@+id/roomIDTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text=""
        android:layout_margin="10dp"
        android:textColor="@color/black"
        android:textSize="12sp"
        android:layout_below="@+id/logView"/>

    <TextView
        android:id="@+id/userIDTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text=""
        android:layout_margin="5dp"
        android:textColor="@color/black"
        android:textSize="12sp"
        android:layout_below="@+id/roomIDTextView"/>

    <TextView
        android:id="@+id/publishStreamIDTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text=""
        android:layout_margin="5dp"
        android:textColor="@color/black"
        android:textSize="12sp"
        android:layout_below="@+id/userIDTextView"/>

    <Button
        android:id="@+id/stopButton"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Stop"
        android:textSize="15sp"
        android:layout_alignParentBottom="true"
        android:layout_marginBottom="30dp"
        android:layout_centerHorizontal="true"/>


    <TextureView
        android:id="@+id/playView"
        android:layout_width="108dp"
        android:layout_height="192dp"
        android:layout_below="@id/logView"
        android:layout_alignParentRight="true"
        android:layout_margin="10dp"/>

</RelativeLayout>
```
</details>


<h1 id="CreateEngine"> </h1>

**2. 创建引擎**

调用 [createEngine \|_blank](@createEngine) 接口，将申请到的 AppID 传入参数 “appID” ，创建引擎单例对象。



```Java
// 创建 ZegoExpress 实例，监听常用事件
ZegoEngineProfile profile = new ZegoEngineProfile();
profile.appID = ;  // 请通过官网注册获取，格式为：1234567890L
profile.scenario = ZegoScenario.DEFAULT;  // 通用场景接入
profile.application = getApplication();
engine = ZegoExpressEngine.createEngine(profile, null);
```

**3. 设置回调**

您可以通过实现 [IZegoEventHandler\|_blank](@-IZegoEventHandler) 接口中的特定方法（或者通过匿名内部类），以监听并处理所关注的事件回调。然后将接口实现类（或者匿名内部类）的对象作为`eventHandler`参数传递给 [createEngine \|_blank](@createEngine) 方法或者传递给 [setEventHandler\|_blank](@setEventHandler-ZegoExpressEngine) 注册回调。

<div class="mk-warning">

建议在创建引擎时或创建引擎后就立即注册回调，以避免延后注册错过事件通知。
</div>


<details class="zg-primary">
    <summary>常见通知回调</summary>

**1. 我在房间内的连接状态变化通知**

[onRoomStateChanged\|_blank](@onRoomStateChanged)：本地调用 [loginRoom\|_blank](@loginRoom) 加入房间时，您可通过监听 [onRoomStateChanged\|_blank](@onRoomStateChanged) 回调实时监控自己在本房间内的连接状态。

您可以在回调中根据不同状态处理业务逻辑。

```Java
@Override
public void onRoomStateChanged(String roomID, ZegoRoomStateChangedReason reason, int errorCode, JSONObject extendedData)
{
    super.onRoomStateChanged(roomID, reason, errorCode, extendedData);
}
```

ZegoRoomStateChangedReason 状态含义如下，更多信息请参考 [房间状态管理 \|_blank](#14774)：

@@@Room_State_Change_Android@@@


**2. 其他用户进出房间的通知**

[onRoomUserUpdate \|_blank](@onRoomUserUpdate)：同一房间内的其他用户进出房间时，您可通过此回调收到通知。回调中的参数 [ZegoUpdateType \|_blank](@-ZegoUpdateType) 为 ZegoUpdateType.ADD 时，表示有用户进入了房间；[ZegoUpdateType \|_blank](@-ZegoUpdateType) 为 ZegoUpdateType.DELETE 时，表示有用户退出了房间。

<div class="mk-warning">

- 只有在登录房间 [loginRoom \|_blank](@loginRoom) 时传的配置 [ZegoRoomConfig \|_blank](@-ZegoRoomConfig) 中的 [isUserStatusNotify \|_blank](@isUserStatusNotify) 参数为 true 时，用户才能收到房间内其他用户的回调。
- 房间人数大于 500 人的情况下 onRoomUserUpdate 回调不保证有效。若业务场景存在房间人数大于 500 的情况，请联系 ZEGO 技术支持。

</div>

```Java
@Override
public void onRoomUserUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoUser> userList) {
    super.onRoomUserUpdate(roomID, updateType, userList);
    // 您可以在回调中根据用户的进出/退出情况，处理对应的业务逻辑
    if (updateType == ZegoUpdateType.ADD) {
        for (ZegoUser user : userList) {
            //("用户 %s 进入了房间 %s", user.userName, roomID);
        }
    } else if (updateType == ZegoUpdateType.DELETE) {
        for (ZegoUser user : userList) {
            //("用户 %s 退出了房间 %s", user.userName, roomID);
        }
    }
}
```

**3. 用户推送音视频流的状态通知**

[onPublisherStateUpdate\|_blank](@onPublisherStateUpdate)：根据实际应用需要，用户推送音视频流之后，当推送视频流的状态发生变更时（如出现网络中断导致推流异常等情况），您会收到该回调，同时 SDK 会进行自动进行重试。

```Java
@Override
public void onPublisherStateUpdate(String streamID, ZegoPublisherState state, int errorCode, JSONObject extendedData) {
    super.onPublisherStateUpdate(streamID, state, errorCode, extendedData);
    if (errorCode != 0) {
        Log.e("推流状态出错 errorCode: %d", errorCode);
    } else {
        switch (state) {
            case PUBLISHING:
                //("正在推流");
                break;
            case PUBLISH_REQUESTING:
                //("正在请求推流");
                break;
            case NO_PUBLISH:
                //("没有推流");
                break;
        }
    }
}
```

**4. 用户拉取音视频流的状态通知**

[onPlayerStateUpdate\|_blank](@onPlayerStateUpdate)：根据实际应用需要，用户拉取音视频流之后，当拉取视频流的状态发生变更时（如出现网络中断导致拉流异常等情况），您会收到该回调，同时 SDK 会进行自动进行重试。

```Java
@Override
public void onPlayerStateUpdate(String streamID, ZegoPlayerState state, int errorCode, JSONObject extendedData) {
    super.onPlayerStateUpdate(streamID, state, errorCode, extendedData);
    if (errorCode != 0) {
        Log.e("拉流状态出错 streamID: %s, errorCode:%d", streamID, errorCode);
    } else {
        switch (state) {
            case PLAYING:
                //("正在拉流中");
                break;
            case PLAY_REQUESTING:
                //("正在请求拉流中");
                break;
            case NO_PLAY:
                //("未进行拉流");
                break;
        }
    }
}
```
</details>


<a id="createroom"></a>

### 3.3 登录房间

@@@Express_Video_Login_Room_Notes@@@


你可以调用 [loginRoom \|_blank](@loginRoom) 接口登录房间。如果房间不存在，调用该接口时会创建并登录此房间。roomID 和 user 的参数由您本地生成，但是需要满足以下条件：

- 同一个 AppID 内，需保证 “roomID” 全局唯一。  
- 同一个 AppID 内，需保证 “userID” 全局唯一，建议开发者将 “userID” 与自己业务的账号系统进行关联。 

```Java
// ZegoUser 的构造方法 public ZegoUser(String userID) 会将 “userName” 设为与传的参数 “userID” 一样。“userID” 与 “userName” 不能为 “null” 否则会导致登录房间失败。 
ZegoUser user = new ZegoUser("user1");
// 只有传入 “isUserStatusNotify” 参数取值为 “true” 的 ZegoRoomConfig，才能收到 onRoomUserUpdate 回调。
ZegoRoomConfig roomConfig = new ZegoRoomConfig();
//token 由用户自己的服务端生成，为了更快跑通流程，也可以通过 ZEGO 控制台获取临时的音视频 token
roomConfig.token = "xxxx";
roomConfig.isUserStatusNotify = true;
// 登录房间
engine.loginRoom("room1", user, roomConfig, (int error, JSONObject extendedData)->{
    // (可选回调) 登录房间结果，如果仅关注登录结果，关注此回调即可
});
```

#### 登录状态（房间连接状态）回调

调用登录房间接口之后，您可通过监听 [onRoomStateChanged\|_blank](@onRoomStateChanged) 回调实时监控自己在本房间内的连接状态。

```Java
@Override
public void onRoomStateChanged(String roomID, ZegoRoomStateChangedReason reason, int errorCode, JSONObject extendedData) {
    if(reason == ZegoRoomStateChangedReason.LOGINING)
    {
        // 登录中
    }
    else if(reason == ZegoRoomStateChangedReason.LOGINED)
    {
        // 登录成功
        //只有当房间状态是登录成功或重连成功时，推流（startPublishingStream）、拉流（startPlayingStream）才能正常收发音视频
        //将自己的音视频流推送到 ZEGO 音视频云
    }
    else if(reason == ZegoRoomStateChangedReason.LOGIN_FAILED)
    {
        // 登录失败
    }
    else if(reason == ZegoRoomStateChangedReason.RECONNECTING)
    {
        // 重连中
    }
    else if(reason == ZegoRoomStateChangedReason.RECONNECTED)
    {
        // 重连成功
    }
    else if(reason == ZegoRoomStateChangedReason.RECONNECT_FAILED)
    {
        // 重连失败
    }
    else if(reason == ZegoRoomStateChangedReason.KICK_OUT)
    {
        // 被踢出房间
    }
    else if(reason == ZegoRoomStateChangedReason.LOGOUT)
    {
        // 登出成功
    }
    else if(reason == ZegoRoomStateChangedReason.LOGOUT_FAILED)
    {
        // 登出失败
    }
}
```

<a id="publishingStream"></a>


### 3.4 主播预览自己的画面，并推送到 ZEGO 音视频云

**1. （可选）主播预览自己的画面**


如果希望看到本端的画面，可调用 [startPreview \|_blank](@startPreview) 接口设置预览视图，并启动本地预览。

```Java
// 设置本地预览视图并启动预览，视图模式采用 SDK 默认的模式，等比缩放填充整个 View
ZegoCanvas previewCanvas = new ZegoCanvas(previewView);
engine.startPreview(previewCanvas);
```

**2. 主播将自己的音视频流推送到 ZEGO 音视频云**

在用户调用 [loginRoom \|_blank](@loginRoom) 接口后，可以直接调用 [startPublishingStream \|_blank](@startPublishingStream) 接口，传入 “streamID”，将自己的音视频流推送到 ZEGO 音视频云。您可通过监听 [onPublisherStateUpdate \|_blank](@onPublisherStateUpdate) 回调知晓推流是否成功。

“streamID” 由您本地生成，但是需要保证：

同一个 AppID 下，“streamID” 全局唯一。如果同一个 AppID 下，不同用户各推了一条 “streamID” 相同的流，后推流的用户推流失败。 

此处示例在调用 [loginRoom \|_blank](@loginRoom) 接口后立即进行推流。在实现具体业务时，您可选择其他时机进行推流，只要保证先调用 [loginRoom \|_blank](@loginRoom) 即可。

```Java
// 用户调用 loginRoom 之后再调用此接口进行推流
// 在同一个 AppID 下，开发者需要保证“streamID” 全局唯一，如果不同用户各推了一条 “streamID” 相同的流，后推流的用户会推流失败。 
engine.startPublishingStream("stream1");
```

@@@Warning_How_to_switch_devices@@@

### 3.5 拉取主播的音视频

进行直播时，我们需要拉取到主播的音视频。超低延迟直播拉流的延迟在 1s 以内，更能实现超低延迟、超强同步、抗极端弱网、超低卡顿、超清画质、首帧秒开的极致直播体验。

在同一房间内的其他用户将音视频流推送到 ZEGO 音视频云时，我们会在 [onRoomStreamUpdate\|_blank](@onRoomStreamUpdate) 回调中收到音视频流新增的通知，并可以通过 ZegoStream 获取到某条流的 “streamID”。

我们可以在该回调中，调用 [startPlayingStream\|_blank](@startPlayingStream) 接口，传入 “streamID” 拉取播放该用户的音视频。您可通过监听 [onPlayerStateUpdate |_blank](@onPlayerStateUpdate) 回调知晓是否成功拉取音视频。您可以使用如下拉流方式。

<div class="mk-warning">

- 超低延迟直播不是默认开启的，请在 ZEGO 控制台自助开通或联系 ZEGO 技术支持，详情请参考 [3.1 开通服务](13395#3_1)。
- 如果用户在直播的过程中，遇到相关错误，可查询 [错误码\|_blank](!Error_Code/Error_Code)。
</div>

调用 [startPlayingStream\|_blank](@startPlayingStream) 接口，并将 [resourceMode\|_blank](@resourceMode-ZegoPlayerConfig) 参数设置为 “ZegoStreamResourceMode.ONLY_L3”，表示超低延迟直播拉流。


```Java
// 房间内其他用户推流/停止推流时，我们会在这里收到相应流增减的通知
public void onRoomStreamUpdate(String roomID, ZegoUpdateType updateType, ArrayList<ZegoStream> streamList, JSONObject extendedData) {
    super.onRoomStreamUpdate(roomID, updateType, streamList, extendedData);
    //当 updateType 为 ZegoUpdateType.ADD 时，代表有音视频流新增，此时我们可以调用 startPlayingStream 接口拉取播放该音视频流
    if (updateType == ZegoUpdateType.ADD) {
         // 开始拉流，设置远端拉流渲染视图，视图模式采用 SDK 默认的模式，等比缩放填充整个 View
        // 如下 playView 为 UI 界面上 View.这里为了使示例代码更加简洁，我们只拉取新增的音视频流列表中第的第一条流，在实际的业务中，建议开发者循环遍历 streamList ，拉取每一条音视频流 
        ZegoStream stream = streamList.get(0);
        playStreamID = stream.streamID;
        ZegoCanvas playCanvas = new ZegoCanvas(playView);
        ZegoPlayerConfig playerConfig = new ZegoPlayerConfig();
        playerConfig.resourceMode = ZegoStreamResourceMode.ONLY_L3;
        engine.startPlayingStream(playStreamID, playCanvas, playerConfig);
    }
}
```

### 3.6 调试超低延迟直播功能

@@@Experience_the_Smooth_Live_Streaming@@@


<a id="stopPublishingStream"></a>

### 3.7 停止推送/拉取音视频流

**1. 停止推流，停止预览**

调用 [stopPublishingStream \|_blank](@stopPublishingStream) 接口停止向远端用户发送本端的音视频流。

```Java
// 停止推流
engine.stopPublishingStream();
```

如果启用了本地预览，调用 [stopPreview \|_blank](@stopPreview) 接口停止预览。

```Java
// 停止本地预览
engine.stopPreview();
```

**2. 停止拉流**

调用 [stopPlayingStream \|_blank](@stopPlayingStream) 接口停止拉取远端推送的音视频流。

@@@Express_stopPlayingStream_time@@@

```Java
// 停止拉流
engine.stopPlayingStream("stream1");
```

### 3.8 退出房间

调用 [logoutRoom \|_blank](@logoutRoom) 接口退出房间。

```Java
// 退出房间
engine.logoutRoom();
```

### 3.9 销毁引擎

如果用户彻底不使用音视频功能时，可调用 [destroyEngine \|_blank](@destroyEngine) 接口销毁引擎，释放麦克风、摄像头、内存、CPU 等资源。

- 如果需要监听回调，来确保设备硬件资源释放完成，可在销毁引擎时传入 “callback”。该回调只用于发送通知，开发者不可以在回调内释放与引擎相关的资源。
- 如果不需要监听回调，可传入 “null”。
    ```Java
    ZegoExpressEngine.destroyEngine(null);
    ```



## 4 直播 API 调用时序

<img src="/Pics/QuickStart/quickstart_uml.png" alt="时序图">

## 5 常见问题

##### 1. 调用 [logoutRoom \|_blank](@logoutRoom) 登出房间时能否直接杀掉进程？
调用 [logoutRoom \|_blank](@logoutRoom) 后直接杀掉进程，有一定概率会导致 [logoutRoom \|_blank](@logoutRoom) 信令没发出去，那么 ZEGO 服务端只能等心跳超时后才认为这个用户退出了房间，为了确保 [logoutRoom \|_blank](@logoutRoom) 信令发送出去，建议再调用 [destroyEngine \|_blank](@destroyEngine) 并收到回调后再杀进程。

@@@relevant_quickstart@@@

- [为什么 Android 9 应用锁屏或切后台后采集音视频无效\|_blank](https://doc-zh.zego.im/faq/android_background)
