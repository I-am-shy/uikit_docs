import { getPlatformData } from "/snippets/utils-content-parser.js"

export const ZIMMessageMap = {
  'Android': <a href='https://www.zegocloud.com/article/api?doc=zim_API~java_android~struct~ZIMMessage' target='_blank'>ZIMMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMMessage-class.html' target='_blank'>ZIMMessage</a>,
  'iOS': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_ios~class~ZIMMessage' target='_blank'>ZIMMessage</a>,
  'mac': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_macos~class~ZIMMessage' target='_blank'>ZIMMessage</a>,
  'window': <a href='https://www.zegocloud.com/article/api?doc=zim_API~cpp_windows~class~ZIMMessage' target='_blank'>ZIMMessage</a>,
  'web': <a href='https://www.zegocloud.com/article/api?doc=zim_API~javascript_web~interface~ZIMMessage' target='_blank'>ZIMMessage</a>,
}
export const queryHistoryMessageMap = {
  'Android': <a href='https://www.zegocloud.com/article/api?doc=zim_API~java_android~class~ZIM#query-history-message' target='_blank'>queryHistoryMessage</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIM/queryHistoryMessage.html' target='_blank'>queryHistoryMessage</a>,
  'iOS': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIM#query-history-message-by-conversation-id-conversation-type-config-callback' target='_blank'>queryHistoryMessageByConversationID</a>,
  'mac': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIM#query-history-message-by-conversation-id-conversation-type-config-callback' target='_blank'>queryHistoryMessageByConversationID</a>,
  'window': <a href='https://www.zegocloud.com/article/api?doc=zim_API~cpp_windows~class~ZIM#query-history-message' target='_blank'>queryHistoryMessage</a>,
  'web': <a href='https://www.zegocloud.com/article/api?doc=zim_API~javascript_web~class~ZIM#query-history-message' target='_blank'>queryHistoryMessage</a>,
}
export const peerMessageReceivedMap= {
  'Android': <a href='https://www.zegocloud.com/article/api?doc=zim_API~java_android~class~ZIMEventHandler#on-peer-message-received' target='_blank'>onPeerMessageReceived</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onPeerMessageReceived.html' target='_blank'>onPeerMessageReceived</a>,
  'iOS': <a href='http://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-peer-message-received-info-from-user-id' target='_blank'>peerMessageReceived</a>,
  'mac': <a href='http://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-peer-message-received-info-from-user-id' target='_blank'>peerMessageReceived</a>,
  'window': <a href='https://www.zegocloud.com/article/api?doc=zim_API~cpp_windows~class~ZIMEventHandler#on-group-message-received' target='_blank'>onPeerMessageReceived</a>,
  'web': <a href='https://www.zegocloud.com/article/api?doc=zim_API~javascript_web~interface~ZIMEventHandler#peer-message-received' target='_blank'>peerMessageReceived</a>,
}

export const messageSentStatusChangedMap= {
  'Android': <a href='https://www.zegocloud.com/article/api?doc=zim_API~java_android~class~ZIMEventHandler#on-message-sent-status-changed' target='_blank'>onMessageSentStatusChanged</a>,
  'Flutter': <a href='https://pub.dev/documentation/zego_zim/latest/zego_zim/ZIMEventHandler/onMessageSentStatusChanged.html' target='_blank'>onMessageSentStatusChanged</a>,
  'iOS': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
  'mac': <a href='https://www.zegocloud.com/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
  'window': <a href='https://www.zegocloud.com/article/api?doc=zim_API~cpp_windows~class~ZIMEventHandler#on-message-sent-status-changed' target='_blank'>onMessageSentStatusChanged</a>,
  'web': <a href='https://www.zegocloud.com/article/api?doc=zim_API~javascript_web~interface~ZIMEventHandler#message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
}


# Render Conversation Messages on the Chat Page

---

## Overview

This article describes how to use the ZIM SDK to render conversation messages on a basic one-on-one chat page.

<Frame width="40%" height="40%" >
  <img src="https://media-resource.spreading.io/docuo/workspace564/27e54a759d23575969552654cb45bf89/e6d8589729.png" alt="showMessage.png"/>
</Frame>

## Prerequisites

You have already integrated the ZIM SDK into your project and implemented basic message sending and receiving. For details, refer to [Quick Start - Implement Basic Message Sending and Receiving](../Send%20and%20receive%20messages.mdx).

## Message Data Source Overview

The message data sources that need to be rendered on the page mainly include the following:

1. Historical conversation messages: When you first enter the chat page and view historical messages, you need to query historical conversation messages and render them to the chat interface.
2. Real-time received messages: Real-time received chat messages need to be rendered to the chat interface.
3. Local sent messages: Local sent chat messages (including sending, sending successfully, and sending failed statuses) need to be rendered to the chat interface.



## Get Message Data and Render to the Chat Interface


As an example of a single chat conversation, when you navigate to the chat page, you need to save the corresponding single chat **conversationID** (the userID of the other party) and maintain a message list `myMessageList` for saving the current conversation.

Before obtaining message data, you also need to implement an `addMessage` utility method to merge message data.


:::if{props.platform="undefined"}
```java
public void addMessage(List<ZIMMessage> addList) {
    if (addList == null || addList.isEmpty()) return;

    List<ZIMMessage> mutableList = new ArrayList<>();
    if (myMessageList != null) {
        mutableList.addAll(myMessageList);
    }

    for (ZIMMessage newMsg : addList) {
        boolean replaced = false;
        for (int i = 0; i < mutableList.size(); i++) {
            ZIMMessage oldMsg = mutableList.get(i);
            if ((newMsg.getMessageID() != null && newMsg.getMessageID().equals(oldMsg.getMessageID())) ||
                (newMsg.getLocalMessageID() != null && newMsg.getLocalMessageID().equals(oldMsg.getLocalMessageID()))) {
                mutableList.set(i, newMsg);
                replaced = true;
                break;
            }
        }
        if (!replaced) {
            mutableList.add(newMsg);
        }
    }

    mutableList.sort(Comparator.comparingLong(ZIMMessage::getOrderKey));
    myMessageList = mutableList;
}

```
:::
:::if{props.platform="iOS|mac"}
```oc
// When there are new messages, update the messages to the message list through this method
- (void)addMessage:(NSArray<ZIMMessage *> *)addList {
    if (!addList || addList.count == 0) return;
    
    NSMutableArray<ZIMMessage *> *mutableList = [self.myMessageList mutableCopy];
    if (!mutableList) {
        mutableList = [NSMutableArray array];
    }
    
    for (ZIMMessage *newMsg in addList) {
        BOOL replaced = NO;
        for (NSInteger i = 0; i < mutableList.count; i++) {
            ZIMMessage *oldMsg = mutableList[i];
            if ((newMsg.messageID && oldMsg.messageID && [newMsg.messageID isEqualToString:oldMsg.messageID]) ||
                (newMsg.localMessageID && oldMsg.localMessageID && [newMsg.localMessageID isEqualToString:oldMsg.localMessageID])) {
                // Replace existing messages
                mutableList[i] = newMsg;
                replaced = YES;
                break;
            }
        }
        if (!replaced) {
            [mutableList addObject:newMsg];
        }
    }
    
    // Sort by orderKey from small to large
    [mutableList sortUsingComparator:^NSComparisonResult(ZIMMessage *msg1, ZIMMessage *msg2) {
        if (msg1.orderKey < msg2.orderKey) return NSOrderedAscending;
        if (msg1.orderKey > msg2.orderKey) return NSOrderedDescending;
        return NSOrderedSame;
    }];
    
    self.myMessageList = [mutableList copy];
}
```
:::

:::if{props.platform="window"}
```cpp
void addMessage(const std::vector<std::shared_ptr<ZIMMessage>>& addList) {
    if (addList.empty()) return;

    std::vector<std::shared_ptr<ZIMMessage>> mutableList = myMessageList;

    for (auto& newMsg : addList) {
        bool replaced = false;
        for (size_t i = 0; i < mutableList.size(); ++i) {
            auto& oldMsg = mutableList[i];
            if ((!newMsg->messageID.empty() && newMsg->messageID == oldMsg->messageID) ||
                (!newMsg->localMessageID.empty() && newMsg->localMessageID == oldMsg->localMessageID)) {
                mutableList[i] = newMsg;
                replaced = true;
                break;
            }
        }
        if (!replaced) {
            mutableList.push_back(newMsg);
        }
    }

    std::sort(mutableList.begin(), mutableList.end(),
              [](const std::shared_ptr<ZIMMessage>& a, const std::shared_ptr<ZIMMessage>& b) {
                  return a->orderKey < b->orderKey;
              });

    myMessageList = mutableList;
}

```
:::
:::if{props.platform="web"}
```ts
function addMessage(addList: ZIMMessage[]) {
    if (!addList || addList.length === 0) return;

    const mutableList: ZIMMessage[] = myMessageList ? [...myMessageList] : [];

    for (const newMsg of addList) {
        let replaced = false;
        for (let i = 0; i < mutableList.length; i++) {
            const oldMsg = mutableList[i];
            if ((newMsg.messageID && oldMsg.messageID && newMsg.messageID === oldMsg.messageID) ||
                (newMsg.localMessageID && oldMsg.localMessageID && newMsg.localMessageID === oldMsg.localMessageID)) {
                mutableList[i] = newMsg;
                replaced = true;
                break;
            }
        }
        if (!replaced) {
            mutableList.push(newMsg);
        }
    }

    mutableList.sort((a, b) => a.orderKey - b.orderKey);
    myMessageList = mutableList;
}

```
:::
:::if{props.platform="Flutter"}
```dart

void addMessage(List<ZIMMessage>? addList) {
  if (addList == null || addList.isEmpty) return;

  List<ZIMMessage> mutableList = myMessageList != null ? List.from(myMessageList!) : [];

  for (var newMsg in addList) {
    bool replaced = false;
    for (var i = 0; i < mutableList.length; i++) {
      var oldMsg = mutableList[i];
      if ((newMsg.messageID != null && oldMsg.messageID != null && newMsg.messageID == oldMsg.messageID) ||
          (newMsg.localMessageID != null && oldMsg.localMessageID != null && newMsg.localMessageID == oldMsg.localMessageID)) {
        mutableList[i] = newMsg;
        replaced = true;
        break;
      }
    }
    if (!replaced) {
      mutableList.add(newMsg);
    }
  }

  mutableList.sort((a, b) => a.orderKey.compareTo(b.orderKey));
  myMessageList = mutableList;
}
```
:::


<Note title="Note">

Each time you call a message-related interface (such as the interfaces shown below), you will get a message list `ZIMMessage[]`. The obtained message list needs to be merged to obtain a message list without duplicate messages and ordered messages for rendering on the message page. The message sorting rule is to sort by the `orderkey` property in {getPlatformData(props,ZIMMessageMap)} (the larger the orderkey, the newer the current message); the de-duplication rule is to determine whether the message object is the same message based on the `localMessageID` of the message, and replace the new data with the old data when it is duplicated.

</Note>

### Query Historical Messages and Render Them to the Chat Interface

Call the {getPlatformData(props,queryHistoryMessageMap)} interface to query historical messages from new to old (from the most recent message to the oldest message in chronological order) and render them to the chat interface.

:::if{props.platform=undefined}
```java

ZIMMessageQueryConfig queryConfig = new ZIMMessageQueryConfig();
queryConfig.count = 20;
queryConfig.nextMessage = null; // When the first query is empty, the earliest message is passed in when more historical messages are needed

zim.queryHistoryMessage(
        myConversationID,
        ZIMConversationType.PEER,
        queryConfig,
        (conversationID, conversationType, messageList, errorInfo) -> {
            addMessage(messageList);
            // update UI
        });
```
:::
:::if{props.platform="iOS|mac"}
```oc
ZIMMessageQueryConfig *queryConfig = [[ZIMMessageQueryConfig alloc] init];
queryConfig.count = 20;//
queryConfig.nextMessage = nil;//When the first query is empty, the earliest message in the message list is passed in again when more historical messages are needed
[zim queryHistoryMessageByConversationID:myConversationID 
            conversationType:ZIMConversationTypePeer 
            config:queryConfig 
            callback:callback:^(NSString * _Nonnull conversationID, ZIMConversationType conversationType, NSArray<ZIMMessage *> * _Nonnull messageList, ZIMError * _Nonnull errorInfo){
    [self addMessage:messageList];            
    // update UI
}];
```
:::
:::if{props.platform="window|mac"}
```cpp

ZIMMessageQueryConfig queryConfig;
queryConfig.count = 20;
queryConfig.nextMessage = nullptr; // When the first query is empty

zim->queryHistoryMessage(
    myConversationID,
    ZIMConversationType::Peer,
    queryConfig,
    [this](const std::string& conversationID, ZIMConversationType type,
           const std::vector<ZIMMessage>& messageList, const ZIMError& errorInfo) {
        addMessage(messageList);
        refreshUI(); // Custom UI refresh function
    });
    
```
:::
:::if{props.platform="web"}
```ts
const queryConfig: ZIMMessageQueryConfig = {
  count: 20,
  nextMessage: null // When the first query is empty
};

zim.queryHistoryMessage(
  myConversationID,
  ZIMConversationType.Peer,
  queryConfig,
  (conversationID, conversationType, messageList, errorInfo) => {
    addMessage(messageList);
    updateUI(); // Custom refresh message list function
  }
);

```
:::
:::if{props.platform="Flutter"}

```dart

final queryConfig = ZIMMessageQueryConfig();
queryConfig.count = 20;
queryConfig.nextMessage = null; // When the first query is empty

zim.queryHistoryMessage(
  myConversationID,
  ZIMConversationType.peer,
  queryConfig,
  (String conversationID, ZIMConversationType conversationType,
      List<ZIMMessage> messageList, ZIMError errorInfo) {
    addMessage(messageList);

    // Update UI
  },
);
```
:::

### Get Real-time Received Messages and Render Them to the Chat Interface

Listen to the {getPlatformData(props,peerMessageReceivedMap)} interface to get real-time received messages and render them to the chat interface.

:::if{props.platform=undefined}

```java
 public void onPeerMessageReceived(ZIM zim, List<ZIMMessage> messageList, 
                                  ZIMMessageReceivedInfo info, String fromUserID) {
    // Only process messages from the current conversation
    if (!fromUserID.equals(myConversationID)) {
        return; // Messages from non-current conversations are ignored
    }

    // Merge messages into message list
    addMessage(messageList);

    // Update UI, such as refreshing RecyclerView
    runOnUiThread(() -> {
        myAdapter.notifyDataSetChanged();
        if (!myMessageList.isEmpty()) {
            recyclerView.scrollToPosition(myMessageList.size() - 1);
        }
    });
}

```
:::
:::if{props.platform="iOS|mac"}
```oc

- (void)zim:(ZIM *)zim
    peerMessageReceived:(NSArray<ZIMMessage *> *)messageList
                   info:(ZIMMessageReceivedInfo *)info
             fromUserID:(NSString *)fromUserID{
     if(fromUserID != myConversationID){
         return;// Messages from non-current conversations are ignored
     }
     [self addMessage: messageList];
     // update UI
 }
```
:::
:::if{props.platform="window"}
```cpp

void onPeerMessageReceived(ZIM* zim, const std::vector<ZIMMessage>& messageList, 
                           const ZIMMessageReceivedInfo& info, const std::string& fromUserID) {
    // Only process messages from the current conversation
    if (fromUserID != myConversationID) {
        return; // Messages from non-current conversations are ignored
    }

    // Merge messages into message list
    addMessage(messageList);

    // Update UI
    // Assume there is a refresh function refreshUI()
    refreshUI();
}

```
:::
:::if{props.platform="web"}
```ts

function onPeerMessageReceived(
    zim: ZIM,
    messageList: ZIMMessage[],
    info: ZIMMessageReceivedInfo,
    fromUserID: string
) {
    // Only process messages from the current conversation
    if (fromUserID !== myConversationID) return;

    // Merge messages into message list
    addMessage(messageList);

    // Update UI, such as refreshing message list
    updateUI();
}


```
:::
:::if{props.platform="Flutter"}
```dart

void onPeerMessageReceived(
    ZIM zim,
    List<ZIMMessage> messageList,
    ZIMMessageReceivedInfo info,
    String fromUserID,
) {
  // Only process messages from the current conversation
  if (fromUserID != myConversationID) return;

  // Merge messages into message list
  addMessage(messageList);

  // Update UI
  WidgetsBinding.instance.addPostFrameCallback((_) {
    setState(() {});
    if (myMessageList.isNotEmpty) {
      scrollController.jumpTo(scrollController.position.maxScrollExtent);
    }
  });
}
```
:::

### Render Local Sent Messages to the Chat Interface

Listen to the {getPlatformData(props,messageSentStatusChangedMap)} interface to get the change of the sending status of the local sent message (sending, sending successfully, and sending failed), and render the local sent message and its sending status to the chat interface.

:::if{props.platform=undefined}
```java

@Override
public void onMessageSentStatusChanged(List<ZIMMessageSentStatusChangeInfo> messageSentStatusChangeInfoList) {
    for (ZIMMessageSentStatusChangeInfo info : messageSentStatusChangeInfoList) {
        if (!info.getMessage().getConversationID().equals(myConversationID)) {
            continue;
        }
        addMessage(Collections.singletonList(info.getMessage()));
    }
    // Update UI
    runOnUiThread(() -> {
        myAdapter.notifyDataSetChanged();
        if (!myMessageList.isEmpty()) {
            recyclerView.scrollToPosition(myMessageList.size() - 1);
        }
    });
}


```
:::
:::if{props.platform="iOS|mac"}
```oc
- (void)zim:(ZIM *)zim
    messageSentStatusChanged:
        (NSArray<ZIMMessageSentStatusChangeInfo *> *)messageSentStatusChangeInfoList{
       for(ZIMMessageSentStatusChangeInfo *info in messageSentStatusChangeInfoList){
           if(info.message.conversationID != myConversationID){
               continue;
           }
           [self addMessage:info.message];
       }
       // update UI
}

```
:::
:::if{props.platform="window"}
```cpp
void onMessageSentStatusChanged(const std::vector<ZIMMessageSentStatusChangeInfo>& messageSentStatusChangeInfoList) {
    for (const auto& info : messageSentStatusChangeInfoList) {
        if (info.message.conversationID != myConversationID) continue;
        addMessage({info.message}); // Assume addMessage supports vector or list
    }
    refreshUI(); // Custom refresh UI function
}


```
:::
:::if{props.platform="web"}
```ts
zim.onMessageSentStatusChanged = (messageSentStatusChangeInfoList: ZIMMessageSentStatusChangeInfo[]) => {
    for (const info of messageSentStatusChangeInfoList) {
        if (info.message.conversationID !== myConversationID) continue;
        addMessage([info.message]);
    }
    updateUI(); // Custom refresh UI function
};


```
:::
:::if{props.platform="Flutter"}
```dart
void onMessageSentStatusChanged(List<ZIMMessageSentStatusChangeInfo> messageSentStatusChangeInfoList) {
  for (var info in messageSentStatusChangeInfoList) {
    if (info.message.conversationID != myConversationID) continue;
    addMessage([info.message]);
  }
  
  // Update UI
}
```
:::


By following the above steps, you can render historical messages, real-time received messages, and local sent messages (including sending status) in the chat page.