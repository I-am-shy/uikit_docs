---
articleID: 14063
---

import {getPlatformData} from "/snippets/utils-content-parser.js"

export const setEventHandlerMap = {
  'Android': <a href='@setEventHandler' target='_blank'>setEventHandler</a>,
}
export const ZIMTextMessageMap = {
  'Android': <a href='@-ZIMTextMessage' target='_blank'>ZIMTextMessage</a>,
}
export const ZIMCommandMessageMap = {
  'Android': <a href='@-ZIMCommandMessage' target='_blank'>ZIMCommandMessage</a>,
}
export const receivePeerMessageMap = {
  'Android': <a href='@onReceivePeerMessage' target='_blank'>onReceivePeerMessage</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
}
export const sendMessageMap = {
  'Android': <a href='@sendMessage' target='_blank'>sendMessage</a>,
}
export const onReceivePeerMessageMap = {
  'Android': <a href='@onReceivePeerMessage' target='_blank'>onReceivePeerMessage</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-peer-message-from-room-id' target='_blank'>receivePeerMessage</a>,
}
export const onReceiveRoomMessageMap = {
  'Android': <a href='@onReceiveRoomMessage' target='_blank'>onReceiveRoomMessage</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-room-message-from-room-id' target='_blank'>onReceiveRoomMessage</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-room-message-from-room-id' target='_blank'>onReceiveRoomMessage</a>,
}
export const onReceiveGroupMessageMap = {
  'Android': <a href='@onReceiveGroupMessage' target='_blank'>onReceiveGroupMessage</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>onReceiveGroupMessage</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-receive-group-message-from-group-id' target='_blank'>onReceiveGroupMessage</a>,
}
export const sendMediaMessageMap = {
  'Android': <a href='@sendMediaMessage' target='_blank'>sendMediaMessage</a>,
}
export const onMediaUploadingProgressMap = {
  'Android': <a href='@onMediaUploadingProgress' target='_blank'>onMediaUploadingProgress</a>,
}
export const downloadMediaFileMap = {
  'Android': <a href='@downloadMediaFile' target='_blank'>downloadMediaFile</a>,
  'iOS,mac': <a href='@downloadMediaFileWithMessage' target='_blank'>downloadMediaFileWithMessage</a>,
}
export const onMediaDownloadingProgressMap = {
  'Android': <a href='@onMediaDownloadingProgress' target='_blank'>onMediaDownloadingProgress</a>,
  'iOS,mac': <a href='@ZIMMediaDownloadingProgress' target='_blank'>ZIMMediaDownloadingProgress</a>,
}
export const ZIMCustomMessageMap = {
  'Android': <a href='@-ZIMCustomMessage' target='_blank'>ZIMCustomMessage</a>,
}
export const ZIMMessageMap = {
  'Android': <a href='@-ZIMMessage' target='_blank'>ZIMMessage</a>,
}
export const ZIMMessageTypeMap = {
  'Android': <a href='@-ZIMMessageType' target='_blank'>ZIMMessageType</a>,
}
export const isMentionAllMap = {
  'Android': <a href='@isMentionAll-ZIMMessage' target='_blank'>isMentionAll</a>,
}
export const mentionedInfoListMap = {
  'Android': <a href='mentionedInfoList-ZIMConversation' target='_blank'>mentionedInfoList</a>,
}
export const ZIMMessageMentionedTypeMap = {
  'Android': <a href='@-ZIMMessageMentionedType' target='_blank'>ZIMMessageMentionedType</a>,
}
export const onConversationChangedMap = {
  'Android': <a href='@onConversationChanged' target='_blank'>onConversationChanged</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-conversation-changed' target='_blank'>conversationChanged</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-conversation-changed' target='_blank'>conversationChanged</a>,
}
export const ZIMConversationMap = {
  'Android': <a href='@-ZIMConversation' target='_blank'>ZIMConversation</a>,
}
export const queryConversationListMap = {
  'Android': <a href='@queryConversationList' target='_blank'>queryConversationList</a>,
  'iOS,mac': <a href='@queryConversationListWithConfig' target='_blank'>queryConversationListWithConfig</a>,
}
export const queryConversationMap = {
  'Android': <a href='@queryConversation' target='_blank'>queryConversation</a>,
}
export const clearConversationUnreadMessageCountMap = {
  'Android': <a href='@clearConversationUnreadMessageCount' target='_blank'>clearConversationUnreadMessageCount</a>,
}
export const clearConversationTotalUnreadMessageCountMap = {
  'Android': <a href='@clearConversationTotalUnreadMessageCount' target='_blank'>clearConversationTotalUnreadMessageCount</a>,
}
export const onBroadcastMessageReceivedMap = {
  'Android': <a href='@onBroadcastMessageReceived' target='_blank'>onBroadcastMessageReceived</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-broadcast-message-received' target='_blank'>broadcastMessageReceived</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-broadcast-message-received' target='_blank'>broadcastMessageReceived</a>,
}
export const onMessageSentStatusChangedMap = {
  'Android': <a href='@onMessageSentStatusChanged' target='_blank'>onMessageSentStatusChanged</a>,
  'iOS': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_ios~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
  'mac': <a href='https://doc-zh.zego.im/article/api?doc=zim_API~objective-c_macos~protocol~ZIMEventHandler#zim-message-sent-status-changed' target='_blank'>messageSentStatusChanged</a>,
}


# 收发消息

- - -

## 功能简介

ZIM SDK 支持单聊消息、群组消息、房间消息等的收发，以及查询历史消息、删除消息等功能。可广泛应用于娱乐社交、电商购物、在线教育、互动直播等多种场景下。

本文档介绍了如何使用 ZIM SDK 的接口，实现各类消息的收发功能与监听消息的状态。

<Note title="说明">

开发者请根据业务需要，查看 [查询历史消息](./Get%20message%20history.mdx)、[删除消息](./Delete%20messages.mdx) 等功能。
</Note>

## 消息类型

目前 ZIM 支持的消息类型如下：

<table>
<tbody><tr data-row-level="1">
<th>消息类型</th>
<th>说明</th>
<th>特性及适用场景</th>
</tr>
<tr data-row-level="2">
<td>ZIMTextMessage(1)</td>
<td>
文本消息。消息大小不超过 32 KB，单个客户端发送频率限制为 10 次/秒。
</td>
<td>
消息可靠有序，可存储为历史消息（保存时间请参考 [计费说明 - 版本说明](../../Introduction/Pricing.mdx) 中“历史消息存储天数”。）；
一般适用于“单聊”、“群聊”等即时聊天的场景和“房间聊天”的公屏聊天场景。房间解散后，“房间聊天”的消息不存储。

相关接口： {getPlatformData(props,sendMessageMap)}
</td>
</tr>
<tr data-row-level="3">
<td>ZIMCommandMessage(2)</td>
<td>开发者可自定义数据内容的信令消息。消息大小不超过 5 KB，单个客户端发送频率限制为 10 次/秒。</td>
<td>
不可存储，支持更高的并发；一般适用于“语聊房”、“在线课堂”等房间内的信令传输，比如上下麦操作、送礼物，发送在线课堂课件等。

相关接口： {getPlatformData(props,sendMessageMap)}
</td>
</tr>
<tr data-row-level="4">
<td>ZIMBarrageMessage(20)</td>
<td>房间内弹幕文本消息。消息大小不超过 5 KB，单个客户端发送频率无限制。</td>
<td>
<p>不可存储，专门用于房间内的高频、不可靠、允许丢掉的消息，一般适用于发送“弹幕消息”的场景中。</p><p>支持高并发，但不可靠，不保证消息送达。</p>

相关接口：{getPlatformData(props,sendMessageMap)}
</td>
</tr>
<tr data-row-level="5">
<td>ZIMImageMessage(11)</td>
<td>图片消息。支持主流图片格式，包括 JPG、PNG、BMP、TIFF、GIF、WebP，大小不超过 10 MB，单个客户端发送频率限制为 10 次/秒。</td>
<td rowspan="4">
消息可靠有序，可存储为历史消息（保存时间请参考 [计费说明 - 版本说明](../../Introduction/Pricing.mdx) 中“历史消息存储天数”。）；
一般用于单聊、房间、群聊等即时聊天场景。

相关接口：{getPlatformData(props,sendMessageMap)}
</td>
</tr>
<tr data-row-level="6">
<td>ZIMFileMessage(12)</td>
<td>文件消息。消息内容为文件，格式不限，大小不超过 100 MB，单个客户端发送频率限制为 10 次/秒。</td>
</tr>
<tr data-row-level="7">
<td>ZIMAudioMessage(13)</td>
<td>语音消息。支持 MP3、M4A 格式的语音文件，时长不超过 300 秒，大小不超过 6 MB，单个客户端发送频率限制为 10 次/秒。</td>
</tr>
<tr data-row-level="8">
<td>ZIMVideoMessage(14)</td>
<td>视频消息。支持 MP4、MOV 格式的视频文件，大小不超过 100 MB，单个客户端发送频率限制为 10 次/秒。**仅支持视频编码格式为 H264 和 H265 的视频文件在消息发送成功后获取该视频首帧的宽、高信息。**</td>
</tr>
<tr data-row-level="9">
<td>ZIMCombineMessage(100)</td>
<td>合并消息，消息大小无限制，单个客户端发送频率限制为 10 次/秒。</td>
<td>
消息可靠有序，可存储为历史消息（保存时间请参考 [计费说明 - 版本说明](../../Introduction/Pricing.mdx) 中“历史消息存储天数”。）；
一般用于单聊、房间、群聊等即时聊天场景。

相关接口：{getPlatformData(props,sendMessageMap)}
</td>
</tr>
<tr data-row-level="10">
<td>ZIMCustomMessage(200)</td>
<td>自定义消息。开发者可自定义消息的类型，并自行完成消息的解析，ZIM SDK 不负责定义和解析自定义消息的具体内容。</td>
<td>
消息可靠有序，可存储为历史消息（保存时间请参考 [计费说明 - 版本说明](../../Introduction/Pricing.mdx) 中“历史消息存储天数”。）；
一般可用于发送投票类型、接龙类型、视频卡片类型等消息。

相关接口：{getPlatformData(props,sendMessageMap)}
</td>
</tr>
</tbody>
</table>

## 收发普通消息

普通消息，包含 ZIMTextMessage、ZIMBarrageMessage 等消息类型。

<Warning title="注意">

- 开发者可以通过注册 {getPlatformData(props,setEventHandlerMap)} 监听，用于接收相关通知（接收房间消息、连接状态、token 即将过期等通知）。
- 接收消息时，收到的消息类型是基类 {getPlatformData(props,ZIMMessageMap)} 。开发者需要根据其中的 `type`（具体请参考 {getPlatformData(props,ZIMMessageTypeMap)} ）字段，判断消息类型是 Text 还是 Command，然后强转基类为具体的子类（ {getPlatformData(props,ZIMTextMessageMap)} 或 {getPlatformData(props,ZIMCommandMessageMap)} ），然后从 “message” 字段获取消息内容。
- 接收消息时，可以使用消息的 orderkey 来实现排序；即 orderkey 越大，消息的时间越新。接收到消息后，会自动更新消息未读数量。
</Warning>


### 发送消息

以客户端 A 向客户端 B 发送消息为例： 

<Frame width="512" height="auto" caption=""><img src="https://storage.zego.im/sdk-doc/Pics/ZIM/Common/send_receive_peerMessage.png" /></Frame>

1. 客户端 A、B 分别创建自己的 ZIM 实例，并注册 {getPlatformData(props,setEventHandlerMap)} 监听的 {getPlatformData(props,onReceivePeerMessageMap)} 回调接口，用于接收单聊消息通知。
2. 客户端 A、B 分别登录 ZIM SDK。
3. 客户端 A 调用 {getPlatformData(props,sendMessageMap)} 接口，设置 `conversationType` 为 `ZIMConversationType.Peer` 发送一条单聊消息到客户端 B。
4. 客户端 B 将通过 {getPlatformData(props,onReceivePeerMessageMap)} 回调接口，收到客户端 A 的消息。

<Warning title="注意">

目前 ZIM 不支持调用 `sendMessage` 接口，向自己发送消息（即 toConversationID = 自己的 ID）。如果尝试向自己发送消息，会返回错误 6000001，并提示传入参数错误。
</Warning>
:::if{props.platform=undefined}
<CodeGroup>
```java title="示例代码"
// 1、创建 ZIM 对象，传入 appID、appSign 与 Android 中的 Application
ZIMAppConfig appConfig = new ZIMAppConfig();
appConfig.appID = 12345;  //替换为您申请到的 AppID
appConfig.appSign = "appSign";   //替换为您申请到的 AppSign
zim = ZIM.create(appConfig, application);

// 2、设置 setEventHandler 回调
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // 收到单聊消息的回调
    }
});

// 3、登录
ZIMUserInfo zimUserInfo = new ZIMUserInfo();
zimUserInfo.userID = "xxxx";
zimUserInfo.userName = "xxxx";
zim.login(zimUserInfo, new ZIMLoggedInCallback() {
    @Override
    public void onLoggedIn(ZIMError error) {
          // 开发者可根据 ZIMError 来判断是否登录成功。          
    }
 });

// 4、发送普通消息

String toConversationID = "xxxx1";

ZIMTextMessage zimMessage = new ZIMTextMessage();
zimMessage.message = "消息内容";

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// 设置消息优先级
config.priority = ZIMMessagePriority.LOW;
// 设置消息的离线推送配置
ZIMPushConfig pushConfig = new ZIMPushConfig();
pushConfig.title = "离线推送的标题";
pushConfig.content= "离线推送的内容";
pushConfig.extendedData = "离线推送的扩展信息";
config.pushConfig = pushConfig;

// 设置发送的会话类型
// 发送单聊信息
ZIMConversationType type = ZIMConversationType.Peer;

// 发送群聊信息
// ZIMConversationType type = ZIMConversationType.Gourp;

// 发送房间信息
// ZIMConversationType type = ZIMConversationType.Room;

// 5、发送消息

zim.sendMessage(zimMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // 开发者可以通过该回调，监听消息是否开始准备发送。只有当通过本地基础参数检验的消息才会抛出该回调，否则通过 onMessageSent 回调抛出错误。
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // 开发者可以通过该回调监听消息是否发送成功。
    }
});
```
</CodeGroup>
:::
:::if{props.platform="iOS|mac"}
<CodeGroup>
```objc title="示例代码"
// 1、创建 ZIM 对象，传入 appID、appSign
ZIMAppConfig *appConfig = [[ZIMAppConfig alloc] init];
appConfig.appID = (unsigned int)appID;     //替换为您申请到的 AppID
appConfig.appSign = @"appSign";     //替换为您申请到的 AppSign
self.zim = [ZIM createWithAppConfig: appConfig];

// 2、设置 setEventHandler 回调
[self.zim setEventHandler:self];

// 3、登录
ZIMUserInfo *userInfo = [[ZIMUserInfo alloc] init];
userInfo.userID = @"xxxx";
userInfo.userName = @"xxxx";
[self.zim loginWithUserInfo:userInfo callback:^(ZIMError * _Nonnull errorInfo){
    // 开发者可根据 ZIMError 来判断是否登录成功。
}];

NSString *toConversationID = @"xxxx1";

ZIMTextMessage *textMessage = [[ZIMTextMessage alloc] init];
textMessage.message = @"消息内容";

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// 设置消息优先级
config.priority = ZIMMessagePriorityLow;
// 设置消息的离线推送配置。若使用该功能，需要先开通离线推送服务
ZIMPushConfig *pushConfig = [[ZIMPushConfig alloc] init];
pushConfig.title = @"离线推送的标题";
pushConfig.content= @"离线推送的内容";
pushConfig.extendedData = @"离线推送的扩展信息";
config.pushConfig = pushConfig

ZIMMessageSendNotification *notification = [[ZIMMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // 发送前的回调，客户可以在这里获取一个临时对象，该对象与开发者创建的 zimMessage 对象属于同一对象，开发者可利用此特性做一些业务逻辑，如提前展示 UI 等
};

// 4、设置会话类型，选择其一向对应的会话类型发送消息
// 发送单聊信息
ZIMConversationType type = ZIMConversationTypePeer;

// 发送群聊信息
ZIMConversationType type = ZIMConversationTypeGroup;

// 发送房间信息
ZIMConversationType type = ZIMConversationTypeRoom;

// 5、发送消息
[self.zim sendMessage:textMessage toConversationID:toConversationID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // 开发者可以通过该回调监听消息是否发送成功。
}];
```
</CodeGroup>
:::

### 接收消息

<Note title="说明">

- 发送消息时，统一使用 {getPlatformData(props,sendMessageMap)} 接口，并根据消息类型传入对应的 ZIMConversationType 取值。
- 接收消息时：
  + 单聊消息（Peer 类型），通过 {getPlatformData(props,onReceivePeerMessageMap)} 回调接收。
  + 房间消息（Room 类型），通过 {getPlatformData(props,onReceiveRoomMessageMap)} 回调接收。
  + 群组消息（Group 类型），通过 {getPlatformData(props,onReceiveGroupMessageMap)} 回调接收。
</Note>

:::if{props.platform=undefined}
```java
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // 收到“单聊”通信的消息回调
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "收到的文本消息:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "收到的信令消息:"+ zimCommandMessage.message);
           }    
        }
    }

    @Override
    public void onReceiveGroupMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromGroupID) {
        // 收到群组消息的回调
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "收到的文本消息:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "收到的信令消息:"+ zimCommandMessage.message);
           }    
        }
    }

    @Override
    public void onReceiveRoomMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromRoomID) {
        // 收到房间消息的回调
        for (ZIMMessage zimMessage : messageList) {
           if (zimMessage instanceof ZIMTextMessage) {
                ZIMTextMessage zimTextMessage = (ZIMTextMessage) zimMessage;
                Log.e(TAG, "收到的文本消息:"+ zimTextMessage.message);
           } else if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                Log.e(TAG, "收到的信令消息:"+ zimCommandMessage.message);
           }    
        }
    }
});
```

:::
:::if{props.platform="iOS|mac"}
```objc
//注册 ZIMEventHander 回调
[zim setEventHandler:self];

// 收到单聊消息的回调
- (void)zim:(ZIM *)zim
    receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
            fromUserID:(NSString *)fromUserID{
     // 在此编写收到消息后的业务逻辑    
}

// 收到群组消息的回调
- (void)zim:(ZIM *)zim
    receiveGroupMessage:(NSArray<ZIMMessage *> *)messageList
            fromGroupID:(NSString *)fromGroupID{
    // 在此编写收到消息后的业务逻辑
}

// 收到房间消息的回调
- (void)zim:(ZIM *)zim
    receiveRoomMessage:(NSArray<ZIMMessage *> *)messageList
            fromRoomID:(NSString *)fromRoomID{
    // 在此编写收到消息后的业务逻辑
}
```
:::


## 收发富媒体消息

ZIM SDK 支持发送多种类型的富媒体消息，包含图片、文件、音频、视频等消息类型，开发者可以通过以下步骤实现富媒体文件消息的收发。

1. 用户登录成功后，指定消息类型（图片、文件、音频、视频）、会话类型（单聊、房间、群组）等，向指定会话发送富媒体消息。
2. 接收方用户登录成功后，根据会话类型（单聊、房间、群组）的相关回调监听，接收富媒体消息的相关通知，以及下载富媒体消息文件到本地。

### 发送富媒体消息

用户登录成功后，调用 {getPlatformData(props,sendMediaMessageMap)} 接口，指定会话、消息类型（图片、文件、音频、视频）、会话类型（单聊、房间、群组）、以及相关消息配置，向指定会话发送富媒体消息。

<Warning title="注意">

- 发送富媒体消息时，填写的待发送文件路径，必须使用 `UTF-8` 编码格式。
- 如果需要向房间/群组内发送富媒体消息，消息发送者必须要在这个房间/群组内。
</Warning>


:::if{props.platform=undefined}
<Accordion title="发送“图片”消息示例" defaultOpen="false">
```java
// 发送富媒体消息消息示例 - 单聊 发送图片消息
ZIMImageMessage message = new ZIMImageMessage("/storage/emulated/0/Android/data/packagename/picture/xxx.jpg");
// 如果此处填了网络 URL，SDK 则会透传该路径，而不会经过 ZIM 后台服务处理，同时填入网络 URL 与本地路径，SDK 会优先认为用户想要使用网络 URL
message.setLargeImageDownloadUrl("url");
message.setFileDownloadUrl("url");
message.setThumbnailDownloadUrl("url");
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// 设置消息优先级
config.priority = ZIMMessagePriority.LOW;
// 设置消息的离线推送配置
// 不支持设置房间消息的离线推送配置，如果需要发送房间离线消息，请联系 ZEGO 技术支持开通相关权限
ZIMPushConfig pushConfig = new ZIMPushConfig();
pushConfig.title = "离线推送的标题";
pushConfig.content= "离线推送的内容";
pushConfig.extendedData = "离线推送的扩展信息";
config.pushConfig = pushConfig;

zim.sendMediaMessage(message, toConversationID, ZIMConversationType.PEER, config, new ZIMMediaMessageSentCallback() {
    @Override
    public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
        // 开发者可以通过该回调，监听消息是否开始准备发送。只有当通过本地基础参数检验的消息才会抛出该回调，否则通过 onMessageSent 回调抛出错误。               
    }

    @Override
    public void onMessageAttached(ZIMMediaMessage message){
    
    }

    @Override
    public void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message) {
        // 开发者可以通过该回调监听消息是否发送成功。               
    }
});
```

</Accordion>
<Accordion title="发送“文件”消息示例" defaultOpen="false">
```java
// 发送富媒体消息消息示例 - 单聊 发送文件消息
ZIMFileMessage message = new ZIMFileMessage("/storage/emulated/0/Android/data/packagename/picture/xxx.zip");
// 如果此处填了网络 URL，SDK 则会透传该路径，而不会经过 ZIM 后台服务处理，同时填入网络 URL 与本地路径，SDK 会优先认为用户想要使用网络 URL
message.setFileDownloadUrl("url");
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
config.priority = ZIMMessagePriority.HIGH;
zim.sendMediaMessage(message, conversationID, ZIMConversationType.PEER, config, new ZIMMediaMessageSentCallback() {
    @Override
    public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
               
    }

    @Override
    public void onMessageAttached(ZIMMediaMessage message){
    
    }

    @Override
    public void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message) {
               
    }
});
```

</Accordion>
<Accordion title="发送“音频”消息示例" defaultOpen="false">
```java
// 发送富媒体消息消息示例 - 单聊 发送音频消息
ZIMAudioMessage message = new ZIMAudioMessage("/storage/emulated/0/Android/data/packagename/picture/xxx.mp3", 300); // 这里的300只是举例，单位是秒。

// 如果此处填了网络 URL，SDK 则会透传该路径，而不会经过 ZIM 后台服务处理，同时填入网络 URL 与本地路径，SDK 会优先认为用户想要使用网络 URL
message.setFileDownloadUrl("url");
ZIMMessageSendConfig config = new ZIMMessageSendConfig();

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
config.priority = ZIMMessagePriority.HIGH;
zim.sendMediaMessage(message, conversationID, ZIMConversationType.PEER, config, new ZIMMediaMessageSentCallback() {
    @Override
    public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
               
    }
    
    @Override
    public void onMessageAttached(ZIMMediaMessage message){
    
    }

    @Override
    public void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message) {
               
    }
});
```

</Accordion>
<Accordion title="发送“视频”消息示例" defaultOpen="false">
```java
// 发送富媒体消息消息示例 - 单聊 发送视频消息
ZIMVideoMessage message = new ZIMVideoMessage("/storage/emulated/0/Android/data/packagename/picture/xxx.mp4", 300);//这里单位是秒

// 如果此处填了网络 URL，SDK 则会透传该路径，而不会经过 ZIM 后台服务处理，同时填入网络 URL 与本地路径，SDK 会优先认为用户想要使用网络 URL
message.setFileDownloadUrl("url");
message.videoFirstFrameDownloadUrl("url");
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
config.priority = ZIMMessagePriority.HIGH;
zim.sendMediaMessage(message, conversationID, ZIMConversationType.PEER, config, new ZIMMediaMessageSentCallback() {
    @Override
    public void onMessageSent(ZIMMessage message, ZIMError errorInfo) {
               
    }
   
    @Override
    public void onMessageAttached(ZIMMediaMessage message){
    
    }

    @Override
    public void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message) {
               
    }
});
```

</Accordion>
:::
:::if{props.platform="iOS|mac"}
<Accordion title="发送“图片”消息示例" defaultOpen="false">
```objc
// 发送多媒体消息示例 - 单聊 发送图片消息
ZIMImageMessage *imgMsg = [[ZIMImageMessage alloc] init];

//需填入 UTF-8 格式的本地路径（建议填写 app 本地图片的路径）
//此处以一个相册图片临时路径为例
imgMsg.fileLocalPath = @"/private/var/mobile/Containers/Data/Application/C142EFE6-9DEC-449D-89B7-BF99F2578F98/tmp/D1513E30-2641-440B-B897-48CD43BE1D04.jpeg";

//如果此处填入了网络 URL, SDK 会透传该路径，而不会经过 ZIM 后台服务处理， 同时填入网络 URL 与本地路径，SDK 会优先任务用户想要使用网路 URL
imgMsg.fileDownloadUrl = @"";

ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = 1;
        
ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // 开发者可以监听这个回调执行消息发送前的业务逻辑
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // 开发者可以监听这个回调获取多媒体上传的进度
};

[[ZIM getInstance] sendMediaMessage:imgMsg toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```
</Accordion>
<Accordion title="发送“音频”消息示例" defaultOpen="false">
```objc
// 发送多媒体消息示例 - 单聊 发送音频消息
//需填入 UTF-8 格式的本地路径（建议填写 app 本地音频的路径）,音频时间（单位秒）
//此处以一个本地音频文件路径为例
 ZIMAudioMessage audioMessage = [[ZIMAudioMessage alloc] initWithFileLocalPath:@"/private/var/mobile/Containers/Shared/AppGroup/D5144D14-3FE8-4C6C-8527-01F368B8E49E/File Provider Storage/IMG_0131.mp3" audioDuration:10];

//如果此处填入了网络 URL, SDK 会透传该路径，而不会经过 ZIM 后台服务处理， 同时填入网络 URL 与本地路径，SDK 会优先任务用户想要使用网路 URL
audioMessage.fileDownloadUrl = @"";

ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityHigh;

ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // 开发者可以监听这个回调执行消息发送前的业务逻辑
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // 开发者可以监听这个回调获取多媒体上传的进度
};

[[ZIM getInstance] sendMediaMessage:audioMessage toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```
</Accordion>
<Accordion title="发送“视频”消息示例" defaultOpen="false">
```objc
// 发送多媒体消息示例 - 单聊 发送视频消息
ZIMVideoMessage *videoMessage = [[ZIMVideoMessage alloc] init];

//需填入 UTF-8 格式的本地路径
//此处以一个本地视频路径为例
videoMessage.fileLocalPath = @"/var/mobile/Containers/Data/Application/C142EFE6-9DEC-449D-89B7-BF99F2578F98/Documents/22-08-31-10:23:49.mp4";

//如果此处填入了网络 URL, SDK 会透传该路径，而不会经过 ZIM 后台服务处理， 同时填入网络 URL 与本地路径，SDK 会优先任务用户想要使用网路 URL
videoMessage.fileDownloadUrl = @"";

ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityHigh;

ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // 开发者可以监听这个回调执行消息发送前的业务逻辑
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // 开发者可以监听这个回调获取多媒体上传的进度
};

[[ZIM getInstance] sendMediaMessage:videoMessage toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```

</Accordion>
<Accordion title="发送“文件”消息示例" defaultOpen="false">
```objc
// 发送多媒体消息示例 - 单聊 发送文件消息
ZIMFileMessage *fileMsg = [[ZIMFileMessage alloc] init];

//需填入 UTF-8 格式的本地路径
//此处以文件选择器选中的某个文件地址为例
fileMsg.fileLocalPath = @"/private/var/mobile/Containers/Shared/AppGroup/D5144D14-3FE8-4C6C-8527-01F368B8E49E/File Provider Storage/IMG_0131.HEIC";

//如果此处填入了网络 URL, SDK 会透传该路径，而不会经过 ZIM 后台服务处理， 同时填入网络 URL 与本地路径，SDK 会优先任务用户想要使用网路 URL
fileMsg.fileDownloadUrl = @"";


ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityHigh;

ZIMMediaMessageSendNotification *notification = [[ZIMMediaMessageSendNotification alloc] init];
notification.onMessageAttached = ^(ZIMMessage * _Nonnull message) {
    // 开发者可以监听这个回调执行消息发送前的业务逻辑
};
        
notification.onMediaUploadingProgress = ^(ZIMMediaMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
    // 开发者可以监听这个回调获取多媒体上传的进度
};

[[ZIM getInstance] sendMediaMessage:fileMsg toConversationID:@"conversationID" conversationType:ZIMConversationTypePeer config:sendConfig notification:notification callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
        
}];
```

</Accordion>
:::

#### 富媒体文件消息的发送进度回调

开发者可以通过 {getPlatformData(props,onMediaUploadingProgressMap)} 回调，接收富媒体消息的上传发送进度的相关通知。

:::if{props.platform=undefined}
``` java
void onMediaUploadingProgress(String fileUID, long currentFileSize, long totalFileSize, ZIMMediaMessage message);
```

:::
:::if{props.platform="iOS|mac"}
``` objc
typedef void (^ZIMMediaUploadingProgress)(ZIMMessage *message, unsigned long long currentFileSize, unsigned long long totalFileSize);
```
:::

其中：

- message：正在发送消息的内容。
- currentFileSize：当前已被发送的消息大小。
- totalFileSize：发送消息的总体大小。

### 接收富媒体消息

接收方用户登录成功后，根据会话类型（单聊、房间、群组）的相关回调监听（ {getPlatformData(props,onReceivePeerMessageMap)} 、 {getPlatformData(props,onReceiveRoomMessageMap)} 、 {getPlatformData(props,onReceiveGroupMessageMap)} ），接收富媒体消息的相关通知，然后可以调用 {getPlatformData(props,downloadMediaFileMap)} 接口，下载富媒体消息文件到本地。

下载富媒体消息时，需要指定对应的媒体消息的文件类型。

- 图片消息：可以选择下载原始文件、大图、缩略图。
- 文件/音频消息：仅能选择下载文件/音频的原始文件。
- 视频消息：可以选择下载视频原始文件、视频首帧的缩略图。

:::if{props.platform=undefined}
``` java
// 接收富媒体消息示例 - 单聊 接收富媒体消息
@Override
public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
    super.onReceivePeerMessage(zim, messageList, fromUserID);
    for (ZIMMessage message : messageList) {
        // 收到消息时，可通过消息的 Type 进行判断接收到何种类型的消息
        if (message.getType() == ZIMMessageType.IMAGE) {
            // 获取图片消息
            ZIMImageMessage imageMessage = (ZIMImageMessage) message;
            zim.downloadMediaFile(imageMessage, ZIMMediaFileType.ORIGINAL_FILE, new ZIMMediaDownloadedCallback() {

                @Override
                public void onMediaDownloaded(ZIMMediaMessage message, ZIMError errorInfo) {
                    // 下载完成回调
                }

                @Override
                public void onMediaDownloadingProgress(ZIMMediaMessage message, long currentFileSize, long totalFileSize) {
                    // 下载进度回调
                }
            });
        } else if (message.getType() == ZIMMessageType.VIDEO) {
            // 获取视频消息
            ZIMVideoMessage videoMessage = (ZIMVideoMessage) message;
        } else if (message.getType() == ZIMMessageType.AUDIO) {
            // 获取音频消息
            ZIMAudioMessage audioMessage = (ZIMAudioMessage) message;
        } else if (message.getType() == ZIMMessageType.FILE) {
            // 获取文件消息
            ZIMFileMessage fileMessage = (ZIMFileMessage) message;
        }
    }
}
```
:::
:::if{props.platform="iOS|mac"}
``` objc
// 接收多媒体消息示例 - 单聊 接收图片消息
- (void)receivePeerMessage:(NSArray<ZIMMessage *> *)messageList
                fromUserID:(NSString *)fromUserID{
    for (ZIMMessage *msg in reverseMsgList) {

        // 收到消息时，可通过消息的 Type 进行判断接收到何种类型的消息
        switch (msg.type) {
            case ZIMMessageTypeImage:{
                ZIMImageMessage *imageMsg = (ZIMImageMessage *)msg;
                [[ZIM getInstance] downloadMediaFileWithMessage:imageMsg fileType:ZIMMediaFileTypeOriginalFile progress:^(ZIMMessage * _Nonnull message, unsigned long long currentFileSize, unsigned long long totalFileSize) {
                            
                            } callback:^(ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo) {
                                
                }];
                break;
            }
            case ZIMMessageTypeVideo:{
                ZIMVideoMessage *videoMsg = (ZIMVideoMessage *)msg;
                break;
            }
            case ZIMMessageTypeAudio:{
                ZIMAudioMessage *audioMsg = (ZIMAudioMessage *)msg;
                break;
            }
            case ZIMMessageTypeFile:{
                ZIMFileMessage *fileMsg = (ZIMFileMessage *)msg;
                break;
            }
            default:
                break;
        }
        
    }
}
```
:::

#### 富媒体文件消息的下载进度回调

开发者可以通过 {getPlatformData(props,onMediaDownloadingProgressMap)} 回调，接收富媒体消息的下载进度的相关通知。

:::if{props.platform=undefined}

``` java
void onMediaDownloadingProgress(ZIMMessage message, long currentFileSize, long totalFileSize);
```
:::
:::if{props.platform="iOS|mac"}

``` objc
typedef void (^ZIMMediaDownloadingProgress)(ZIMMessage *message, unsigned long long currentFileSize, unsigned long long totalFileSize);
```
:::

其中：

- message：正在下载的消息内容。
- currentFileSize：当前已被下载的消息大小。
- totalFileSize：下载消息的总体大小。

## 收发信令消息

ZIM SDK 支持开发者实现信令类型的消息收发，开发者可以通过 {getPlatformData(props,ZIMCommandMessageMap)} 对象定义自己的消息类型，例如位置消息等。

<Note title="说明">

信令消息不支持离线推送和本地存储。
</Note>


以下以**向指定用户发送信令消息**为例。

### 发送信令消息
:::if{props.platform=undefined}
```java
//向指定用户发送信令消息

// 1、创建 ZIM 对象，传入 appID、appSign 与 Android 中的 Application
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 2、设置 setEventHandler 回调
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 3、登录
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 4、发送信令信息
String userID = "xxxx";

ZIMCommandMessage zimCustomMessage = new ZIMCommandMessage();
zimCustomMessage.message = new byte[]{0x1,0x2,0x1,0x2};

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// 设置消息优先级
config.priority = ZIMMessagePriority.LOW;
// 设置消息的离线推送配置
// 不支持设置房间消息的离线推送配置，如果需要发送房间离线消息，请联系 ZEGO 技术支持开通相关权限
ZIMPushConfig pushConfig = new ZIMPushConfig();
pushConfig.title = "离线推送的标题";
pushConfig.content= "离线推送的内容";
pushConfig.extendedData = "离线推送的扩展信息";
config.pushConfig = pushConfig;

// 发送单聊信息
ZIMConversationType type = ZIMConversationType.Peer;

// 发送群聊信息
// ZIMConversationType type = ZIMConversationType.Gourp;

// 发送房间信息
// ZIMConversationType type = ZIMConversationType.Room;

zim.sendMessage(zimCustomMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // 开发者可以通过该回调，监听消息是否开始准备发送。只有当通过本地基础参数检验的消息才会抛出该回调，否则通过 onMessageSent 回调抛出错误。               
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // 开发者可以通过该回调监听消息是否发送成功。
    }
});

```

:::
:::if{props.platform="iOS|mac"}
```objc
//向指定用户发送信令消息
NSData *anyData = [[NSData alloc] init];
NSString *toUserID = @"toUserID";
ZIMCommandMessage * cmdMsg = [[ZIMCommandMessage alloc] initWithMessage:anyData];
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityMedium;

[self.zim sendMessage:cmdMsg toUserID:toUserID conversationType:type config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // 开发者可以通过该回调监听消息是否发送成功。
}];
```
:::
### 接收信令消息

:::if{props.platform=undefined}
```java
//用户接收信令消息
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // 收到“单聊”通信的消息回调
        for (ZIMMessage zimMessage : messageList) {
            if (zimMessage instanceof ZIMCommandMessage) {
                ZIMCommandMessage zimCommandMessage = (ZIMCommandMessage) zimMessage;
                
           }    
        }
    }
});
```

:::
:::if{props.platform="iOS|mac"}
```objc
//用户接收信令消息
- (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
    if (zim != self.zim) {
        return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMMessageTypeCommand){
            ZIMCommandMessage *cmdMsg = (ZIMCommandMessage *)msg;
            NSData *receivedData = cmdMsg.message;
        }
    }
}
```
:::

## 收发自定义消息

ZIM SDK 支持开发者实现自定义类型的消息收发，开发者可以通过 {getPlatformData(props,ZIMCustomMessageMap)} 对象自行定义消息类型，例如投票类型、接龙类型、视频卡片类型等。开发者可以通过以下步骤实现自定义消息的收发。

<Note title="说明">

- 仅 2.8.0 及以上版本的 ZIM SDK 支持发送自定义类型消息，接收并查看自定义类型消息的内容。
- 如果接收端的 SDK 版本介乎 [2.0.0, 2.8.0) 区间，可以收到自定义消息时，但会显示此消息类型为未知，且无法获取信息内容。如需获取此条消息，请将 SDK 升级为 2.8.0 或以上版本。
- 如果接收端的 SDK 版本为 1.x.x 版本，则无法收到自定义消息，也不会收到未知消息。
</Note>

### 发送自定义消息

发送自定义消息使用的接口为 {getPlatformData(props,sendMessageMap)} ，与发送普通消息所用接口相同，开发者可参考 [收发普通消息 - 发送消息](#发送消息) 了解此接口参数详情。

开发者需要通过 {getPlatformData(props,ZIMCustomMessageMap)} 对象定义自定义类型消息，包括以下参数：

以下为用户在单聊会话中发送自定义消息的示例代码：

:::if{props.platform=undefined}
```java
// 在单聊会话中向指定用户发送自定义消息

// 1、创建 ZIM 对象，传入 appID、appSign 与 Android 中的 Application
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 2、设置 setEventHandler 回调
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 3、登录
// 具体代码请参考上文 [收发普通消息 - 发送消息] 相关代码。

// 4、发送自定义信息
// 指定用户的 ID
String userID = "xxxx";

// 自定义消息的文本内容
String message = "";

// 具体的自定义类型
int subType = 100; 

// 自定义消息的检索字段。
String searchedContent = "";

ZIMCustomMessage zimCustomMessage = new ZIMCustomMessage(message,subType);

// 发送消息的高级属性配置
ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// 设置消息优先级
config.priority = ZIMMessagePriority.LOW;

// 发送单聊信息
ZIMConversationType type = ZIMConversationType.Peer;

// 发送群聊信息
// ZIMConversationType type = ZIMConversationType.Gourp;

// 发送房间信息
// ZIMConversationType type = ZIMConversationType.Room;

zim.sendMessage(zimCustomMessage, toConversationID, type,config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // 开发者可以通过该回调，监听消息是否开始准备发送。只有当通过本地基础参数检验的消息才会抛出该回调，否则通过 onMessageSent 回调抛出错误。               
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // 开发者可以通过该回调监听消息是否发送成功。
    }
});
```

:::

:::if{props.platform="iOS|mac"}
```objc
// 向指定用户发送自定义消息
NSString *message = @"message";
NSString *toUserID = @"toUserID";
ZIMCustomMessage * customMessage = [[ZIMCustomMessage alloc] init];
customMessage.message = message;
customMessage.subType = 1; // 开发者自定义的类型
customMessage.searchContent="";
ZIMMessageSendConfig *sendConfig = [[ZIMMessageSendConfig alloc] init];
sendConfig.priority = ZIMMessagePriorityMedium;

[self.zim sendMessage:customMessage toUserID:toUserID conversationType: ZIMConversationTypePeer config:config notification:notification callback:^((ZIMMessage * _Nonnull message, ZIMError * _Nonnull errorInfo)) {
    // 开发者可以通过该回调监听消息是否发送成功。
}];
```

:::

### 接收自定义消息

接收自定义消息的回调接口与接收普通消息的回调接口一致，请参考 [收发普通消息 - 接收消息](#接收消息) 了解具体接口。

以下为用户在单聊会话中接收自定义消息的示例代码：

:::if{props.platform=undefined}
```java
// 用户在单聊会话中接收自定义消息
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onReceivePeerMessage(ZIM zim, ArrayList<ZIMMessage> messageList, String fromUserID) {
        // 收到“单聊”消息的回调
        for (ZIMMessage zimMessage : messageList) {
            if (zimMessage instanceof ZIMCustomMessage) {
                ZIMCustomMessage zimCustomMessage = (ZIMCustomMessage) zimMessage;
                
           }    
        }
    }
});
```

:::
:::if{props.platform="iOS|mac"}
```objc
// 用户在单聊会话中接收自定义消息
- (void)zim:(ZIM *)zim receivePeerMessage:(NSArray<ZIMMessage *> *)messageList fromUserID:(NSString *)fromUserID {
    if (zim != self.zim) {
        return;
    }
    for (ZIMMessage *msg in messageList) {
        if(msg.type == ZIMCustomMessage){
            // 这里表示接收到自定义消息
        }
    }
}
```

:::

## 收发 @ 消息

@ 消息，是指包含“@ + 用户”内容的消息。被 @ 的用户在收到消息时会强提醒。

<Note title="说明">

@ 消息不属于消息类型。一条消息既可以是文本消息或其他类型消息，同时也是 @ 消息。
</Note>

### 发送 @ 消息

在调用 {getPlatformData(props,sendMessageMap)} 发送消息时，可以通过以下方法（可同时使用）将一条消息设置为 @ 信息：
- `setMentionedUserIDs`：提醒指定用户（可以是会话外用户）查看消息。传入的 userID 列表长度最多为 50，如需上调，请联系 ZEGO 技术支持。
- `setIsMentionAll`：提醒会话内所有其他用户查看消息。

<Note title="说明">

仅 2.14.0 及以上版本的 ZIM SDK 支持发送消息中带 @ 信息。
</Note>
:::if{props.platform=undefined}
```java
// 以下为用户在单聊会话中发送 @ 消息的示例代码：

// 创建提醒用户列表
ArrayList<String> mentionArrayList = new ArrayList<>();

// 添加提醒用户（用户可以不在当前会话）
mentionArrayList.add("userId1");
mentionArrayList.add("userId2");

// message 可以为任何类型消息
// 调用接口提醒列表中用户查看消息
message.setMentionedUserIDs(mentionArrayList);

// 提醒会话内所有其他用户查看消息
boolean isMentionAll = true;
message.setIsMentionAll(isMentionAll);

ZIMMessageSendConfig config = new ZIMMessageSendConfig();
// 设置消息优先级
config.priority = ZIMMessagePriority.LOW;

// 是否强推送给被提醒用户（不管对方是否开启了会话免打扰），默认为fasle;
config.isNotifyMentionedUsers = true;

// 以发送单聊信息为例子
ZIMConversationType type = ZIMConversationType.Peer;

zim.sendMessage(message,"conv_id", type, config, new ZIMMessageSentCallback() {
    @Override
    public void onMessageAttached(ZIMMessage zimMessage) {
        // 开发者可以通过该回调，监听消息是否开始准备发送。只有当通过本地基础参数检验的消息才会抛出该回调，否则通过 onMessageSent 回调抛出错误。               
    }

    @Override
    public void onMessageSent(ZIMMessage zimMessage, ZIMError error) {
        // 开发者可以通过该回调监听消息是否发送成功。
    }
});
```

:::
:::if{props.platform="iOS|mac"}

```objc
// 以下为用户在单聊会话中发送 @ 消息的示例代码：
// 创建提醒用户列表
NSMutableArray<NSString *> *mentionArrayList = [[NSMutableArray alloc] init];

// 添加提醒用户（用户可以不在当前会话）
[mentionArrayList addObject:@"userId1"];
[mentionArrayList addObject:@"userId2"];

// message 可以为任何类型消息
// 调用接口提醒列表中用户查看消息
[message mentionedUserIDs:mentionArrayList];

// 提醒会话内所有其他用户查看消息
BOOL isMentionAll = YES;
[message isMentionAll:isMentionAll];

ZIMMessageSendConfig *config = [[ZIMMessageSendConfig alloc] init];
// 是否强推送给被提醒用户（不管对方是否开启了会话免打扰），默认为 NO;
config.isNotifyMentionedUsers = YES;

// 以发送单聊信息为例
ZIMConversationType type = ZIMConversationTypePeer;

[zim sendMessage:message convId:@"conv_id" type:type config:config callback:^(ZIMMessage *zimMessage, ZIMError *error) {
    if (error) {
        // 开发者可以通过该回调监听消息是否发送成功。
    }
}];

```
:::

### 接收 @ 消息

接收 @ 消息的回调接口与接收普通消息的回调接口一致，请参考 [收发普通消息 - 接收消息](#接收消息) 了解具体接口。

收到消息后，开发者可根据业务逻辑实现对应的功能，如高亮等。

<Note title="说明">

- 仅 2.14.0 及以上版本的 ZIM SDK 支持接收并查看 @ 信息中的内容。
- 如果接收端的 SDK 版本介乎 [2.0.0, 2.14.0) 区间，则收到的消息和会话中不会带 @ 信息。
- 如果接收端的 SDK 版本为 1.x.x 版本，则无法收到 @ 信息。
</Note>

### 获取 mentionedInfoList

当会话内用户被提醒后，可以被动或主动获取 {getPlatformData(props,mentionedInfoListMap)} 。

{getPlatformData(props,mentionedInfoListMap)}，包含 @ 消息的对应消息 ID，发送者 userID，以及 @ 消息的类型 {getPlatformData(props,ZIMMessageMentionedTypeMap)} ，开发者可用于实现标记会话等多样业务逻辑。

#### 被动获取

在用户被提醒时，会收到 {getPlatformData(props,onConversationChangedMap)} 回调，即可获取当前 {getPlatformData(props,ZIMConversationMap)} 的最新 {getPlatformData(props,mentionedInfoListMap)} 。

:::if{props.platform=undefined}
```java
@Override
    public void onConversationChanged(
        ZIM zim, ArrayList<ZIMConversationChangeInfo> conversationChangeInfoList) {
        // conversationChangeInfoList 可拿到收到提醒的会话里面的 mentionInfoList 
    }
```

:::
:::if{props.platform="iOS|mac"}
```objc
- (void)zim:(ZIM *)zim
    conversationChanged:(NSArray<ZIMConversationChangeInfo *> *)conversationChangeInfoList {
        // conversationChangeInfoList 可拿到收到提醒的会话里面的 mentionInfoList 
    }
```
:::
#### 主动获取

如用 {getPlatformData(props,queryConversationListMap)} 或者 {getPlatformData(props,queryConversationMap)} 主动拉取会话，也可获取会话里面的 {getPlatformData(props,mentionedInfoListMap)} ，可参考以下示例代码：

:::if{props.platform=undefined}

```java
ArrayList<ZIMMessageMentionedInfo> mentionedInfoList = conversation.mentionedInfoList;
```
:::
:::if{props.platform="iOS|mac"}
```objc
NSArray<ZIMMessageMentionedInfo *> * mentionedInfoList = conversation.mentionedInfoList;
```
:::

### 清除会话的 mentionedInfoList

接收 @ 消息后，用户需要清除会话的 {getPlatformData(props,Map)} ，才能不再被提醒。

清除会话的 mentionedInfoList 接口与清除会话消息未读数接口相同：
- {getPlatformData(props,clearConversationUnreadMessageCountMap)} ：清除单个会话消息未读数，调用示例请参考 [会话管理 - 清除单个会话消息未读数](../Conversation/Manage%20unread%20message%20counts.mdx#清除单个会话消息未读数)。
- {getPlatformData(props,clearConversationTotalUnreadMessageCountMap)} ：清除全部会话消息未读数，调用示例请参考 [会话管理 - 清除全部会话消息未读数](../Conversation/Manage%20unread%20message%20counts.mdx#清除全部会话消息未读数)。

### 获取提醒用户列表

会话内所有用户都可以调用 `getMentionedUserIDs` 接口。获取具体提醒用户列表，可此接口仅能返回调用 `setMentionedUserIDs` 接口传入的用户列表。

:::if{props.platform=undefined}
```java
ArrayList<String> userIds = message.getMentionedUserIDs();
```
:::
:::if{props.platform="iOS|mac"}
```objc
NSArray<NSString *> *userIds = message.mentionedUserIDs;
```
:::
### 确认是否为全员提醒

会话内所有用户都可以调用 {getPlatformData(props,isMentionAllMap)} 接口，确认消息是否为全员提醒消息。
:::if{props.platform=undefined}
```java
boolean isMentionAll = message.isMentionAll();
```
:::

:::if{props.platform="iOS|mac"}
```objc
BOOL isMentionAll = message.isMentionAll;
```
:::

## 收发全员推送消息

ZIM 支持您通过服务端向 App 所有在线用户发送消息，目标用户通过客户端接收相关消息。

### 从服务端向所有用户发送消息

请查看服务端 API 文档 [全员推送](/zim-server/messaging/push-message-to-all-users) 文档，实现从服务端向所有用户发送消息。

### 接收服务端发送的全员推送消息

<Note title="说明">

- 仅 2.10.0 及以上版本的 ZIM SDK 支持接收并查看全员推送消息的内容。
- 如果接收端的 SDK 版本介乎 [2.0.0, 2.10.0) 区间，不可以收到服务端发送的全员推送消息，如需获取此条消息，请将 SDK 升级为 2.10.0 或以上版本。
</Note>

通过 {getPlatformData(props,onBroadcastMessageReceivedMap)} 回调，即可接收全员推送消息。

示例代码：
:::if{props.platform=undefined}

```java
// 用户接收全员推送消息
public void onBroadcastMessageReceived(ZIM zim, ZIMMessage message) {
    super.onBroadcastMessageReceived(zim, message);
    // 接收到全员推送消息
}
```
:::
:::if{props.platform="iOS|mac"}
```objc
// 用户接收全员推送消息
- (void)zim:(ZIM *)zim broadcastMessageReceived:(ZIMMessage *)message {
    // 接收到全员推送消息
}
```
:::


## 转发消息

ZIM SDK 支持实现以下两种形式的消息转发：
- 合并消息后转发。
- 逐条消息转发。

具体实现流程，请参考 [转发消息](./Forward%20messages.mdx)。


## 接收 Tips 消息

ZIM SDK 支持用户在会话内的操作转换为 Tips 消息。当相关操作出现后，ZIM SDK 会向会话发送一条 Tips 消息进行通知，详情请参考 [接收 Tips 消息](./Receive%20tip%20messages.mdx)。


## 监听消息状态

在一些弱网场景中，可能存在以下场景，即消息发送成功，但由于某些因素（如网络丢包），导致 ZIM SDK 未收到服务端应答。此时，ZIM SDK 会因应答超时而认为消息发送失败，但实际上消息发送成功，导致消息状态混乱。为解决该问题，明确消息最终状态， 2.6.0 或以上版本 SDK 支持开发者监听 {getPlatformData(props,onMessageSentStatusChangedMap)} 回调，接收消息的状态变化。消息的状态有三种，即 Sending、Success 和 Failed。根据消息状态的变化，开发者可判断消息发送是否成功，并在业务上做相应处理。

:::if{props.platform=undefined}
```java
// 监听消息状态
zim.setEventHandler(new ZIMEventHandler() {
    @Override
    public void onMessageSentStatusChanged(
        ZIM zim, ArrayList<ZIMMessageSentStatusChangeInfo> messageSentStatusChangeInfoList) {
    // 开发者可在这里监听消息状态改变时的回调。
}
});
```
:::
:::if{props.platform="iOS|mac"}
```objc
// 监听消息状态
- (void)zim:(ZIM *)zim messageSentStatusChanged:
        (NSArray<ZIMMessageSentStatusChangeInfo *> *)messageSentStatusChangeInfoList {
            // 开发者可在这里监听消息状态的改变
}
```
:::