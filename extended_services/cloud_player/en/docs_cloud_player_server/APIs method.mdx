# Accessing server APIs

- - -

## Overview

ZEGOCLOUD server API supports the HTTPS network request protocol and allows GET or POST methods.

## Overview of request methods

The server API request consists of different components and has a fixed request structure:

- [Access Address](#11-access-address): The access address of the ZEGOCLOUD server, which may vary depending on the product and region.
- [Common Parameters](#2-common-parameters): Each request must have a series of common parameters.
- [Signature](#3-signature-mechanism): The signature is also a common parameter and needs to be generated according to the corresponding signature algorithm.
- Request Parameters: You need to specify the interface through the Action parameter, such as Action = CreatePlayer; and also specify other parameters of the interface.

After we verify your request based on the signature, we will return the result to you. If the interface call is successful, the return parameters will be displayed. If the call fails, the corresponding error will be displayed. You can analyze and troubleshoot based on the [Return codes](./return%20codes.mdx).


<Accordion title="Server API Request Example" defaultOpen="false">

Here is an example of the request structure for the [`CreatePlayer`](./Create%20Player.mdx) (Create a cloud player) interface:

```
https://cloud-player-api.zego.im/?Action=CreatePlayer
&AppId=1234567890
&SignatureNonce=15215528852396
&Timestamp=1234567890
&Signature=7a2c0f11145fb760d607a07b54825013
&SignatureVersion=2.0
&IsTest=false
```

Among which:
- `https`: Specifies the request communication protocol.
- `cloud-player-api.zego.im`: Specifies the access address of the ZEGOCLOUD server.
- `Action=CreatePlayer`: Specifies the API to be called.
- Other parameters: Common request parameters that are required for each interface, including AppId, SignatureNonce, Signature, etc. Please refer to [Common Request Parameters](#21-common-request-parameters) for details.

</Accordion>

## 1 Request Structure

### 1.1 Access Address

Developers need to specify the corresponding access address based on the geographical region of their server when sending requests to the ZEGOCLOUD server.
<Warning title="Warning">

To ensure the quality of your business service access, please prioritize using the domain name of the geographical region where your server is located as the access address when sending requests to the ZEGOCLOUD server.

</Warning>

ZEGOCLOUD supports request access from the following geographical regions:

<table>
<thead>
  <tr>
    <th>Region</th>
    <th>API base URL</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Chinese Mainland (Shanghai)</td>
    <td>`${PRODUCT}`-api-sha.zego.im</td>
  </tr>
  <tr>
    <td>Hong Kong, Macau and Taiwan (Hong Kong)</td>
    <td>`${PRODUCT}`-api-hkg.zego.im</td>
  </tr>
  <tr>
    <td>Europe (Frankfurt)</td>
    <td>`${PRODUCT}`-api-fra.zego.im</td>
  </tr>
  <tr>
    <td>Western United States (California)</td>
    <td>`${PRODUCT}`-api-lax.zego.im</td>
  </tr>
  <tr>
    <td>Asia-Pacific (Mumbai)</td>
    <td>`${PRODUCT}`-api-bom.zego.im</td>
  </tr>
  <tr>
    <td>Southeast Asia (Singapore)</td>
    <td>`${PRODUCT}`-api-sgp.zego.im</td>
  </tr>
  <tr>
    <td>Unified access address (regardless of region)</td>
    <td>`${PRODUCT}`-api.zego.im</td>
  </tr>
</tbody>
</table>



Where `${PRODUCT}` corresponds to different services provided by ZEGOCLOUD for different products, as follows:

| Product | \$\{PRODUCT} Value | Access Address |
|-|-|-|
| Cloud Player | cloud-player | cloud-player-api.zego.im |


### 1.2 Communication protocol

All ZEGOCLOUD server API interfaces communicate via HTTPS, providing secure communication services.


### 1.3 Request methods

ZEGOCLOUD server API supports the following HTTP request methods:

- GET
- POST

<Note title="Note">

- All request parameters (including common parameters and business parameters) are placed in the Query using the GET request method. For special complex API business parameters, they are placed in the Body using the POST request method.
- When passing parameters using the POST request method, the parameters in the Body can be directly passed in JsonObject format, without the need to serialize them into String format.
</Note>



## 2 Common parameters
This section introduces the common parameters used when developers call the ZEGOCLOUD server API, including common request parameters and common response parameters.

### 2.1 Common request parameters

Common request parameters are required for every interface.

<table>
  
  <tbody><tr>
    <th>Parameter</th>
    <th>Type</th>
    <th>Required</th>
    <th>Description</th>
  </tr>
  <tr>
    <td>AppId</td>
    <td>Uint32</td>
    <td>Yes</td>
    <td>AppId, the unique credential assigned by ZEGOCLOUD.</td>
  </tr>
  <tr>
    <td>Signature</td>
    <td>String</td>
    <td>Yes</td>
    <td>Signature, please refer to <a href="#3-signature-mechanism">3 Signature Mechanism</a> for signature generation.</td>
  </tr>
  <tr>
    <td>SignatureNonce</td>
    <td>String</td>
    <td>Yes</td>
    <td>Random number.</td>
  </tr>
  <tr>
    <td>SignatureVersion</td>
    <td>String</td>
    <td>Yes</td>
    <td>Signature version, <strong>must be filled in as 2.0</strong>.</td>
  </tr>
  <tr>
    <td>Timestamp</td>
    <td>Int64</td>
    <td>Yes</td>
    <td>Unix timestamp in seconds. Allow up to 10 minutes of error.</td>
  </tr>
  <tr>
    <td rowspan="2">IsTest</td>
    <td rowspan="2">String</td>
    <td>Yes (for projects created before 2021-11-16)</td>
    <td>Whether it is a test environment. The values are as follows: <ul><li>true (case-insensitive): test environment</li><li>false (case-insensitive): formal environment (default value)</li></ul><Warning title="Warning">For projects created before <strong>2021-11-16</strong> in the <a target="_blank" href="https://console.zegocloud.com/account/login ">ZEGOCLOUD console</a>:<ul><li>The AppId and AppSign obtained from the console are by default in the test environment.</li><li>This parameter can be set based on the environment type of the AppId and business requirements.</li></ul></Warning></td>
  </tr>
  <tr>
    <td>No (for projects created after 2021-11-16)</td>
    <td>Whether it is a test environment. The default is the formal environment and can be ignored.<Warning title="Warning">For projects created after <strong>2021-11-16</strong> in the <a target="_blank" href="https://console.zegocloud.com/account/login">ZEGOCLOUD console</a>: The AppId and AppSign obtained from the console are all in the formal environment.</Warning></td>
  </tr>
</tbody></table>

<Warning title="Warning">

- Please do not directly copy the following examples for requests.
- The request URL is: https://cloud-player-api.zego.im/?Action=xxxxx&common parameters, where `Action=xxxxx` needs to be replaced with the request URL in the "Interface Prototype" section of each API document.
- Modify the values of each common parameter according to the actual situation.
</Warning>

Request example:

```bash
https://cloud-player-api.zego.im/?Action=DeletePlayer
&AppId=1234567890
&SignatureNonce=15215528852396
&Timestamp=1234567890
&Signature=xxxx
&SignatureVersion=2.0
&IsTest=false
```

### 2.2 Common Response Parameters

The API returns results in a unified format, and the data format returned is JSON.

Every time an interface is called, whether successful or not, common parameters will be returned.

<table>

<thead>
  <tr>
    <th>Parameter</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Code</td>
    <td>Number</td>
    <td>Return code.</td>
  </tr>
  <tr>
    <td>Message</td>
    <td>String</td>
    <td>Operation result description.</td>
  </tr>
  <tr>
    <td>RequestId</td>
    <td>String</td>
    <td>Request ID.</td>
  </tr>
  <tr>
    <td>Data</td>
    <td>-</td>
    <td>Response data.</td>
  </tr>
</tbody>
</table>


Response example:

```json
{
    "Code":0,
    "Data":{
        "MessageId":"1_1611647493487_29"
    },
    "Message":"success",
    "RequestId":"2237080460466033406"
}
```
## 3 Signature Mechanism

To ensure the security of API calls, the ZEGOCLOUD server verifies the identity of each API request. When developers make API calls, they need to include the Signature information in the request.

<Warning title="Warning">
    
A new signature needs to be generated for each API call.  
</Warning>

### 3.1 Key Retrieval

The Signature is generated by calculating the md5 hash of the AppId and ServerSecret to verify the identity of the request sender. The AppId is used to identify the visitor's identity, and the ServerSecret is used as the key to encrypt and verify the signature string. It must be kept strictly confidential to prevent leakage.

Developers can go to the [ZEGOCLOUD Console](https://console.zegocloud.com/account/login) and navigate to "Console > Project Management" to view the AppId of the project. Click on the project to view the ServerSecret and other information in the "Project Configuration" section.


<Frame width="512" height="auto" caption="">
  <img src="https://storage.zego.im/sdk-doc/Pics/Cloud_player/17714_1.jpeg" />
</Frame>
<Frame width="512" height="auto" caption="">
  <img src="https://storage.zego.im/sdk-doc/Pics/Cloud_player/17714_2.jpeg" />
</Frame>
### 3.2 Signature generation

1. Signature parameter description

<table>

<thead>
  <tr>
    <th>Parameter</th>
    <th>Meaning</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>AppId</td>
    <td>Application ID. The AppId in the common parameters is obtained from the [ZEGOCLOUD Console](https://console.zegocloud.com/account/login).</td>
  </tr>
  <tr>
    <td>SignatureNonce</td>
    <td>Random number. The SignatureNonce in the common parameters is generated according to the algorithm described in [3.3 Signature Example](17715#5_3).</td>
  </tr>
  <tr>
    <td>ServerSecret</td>
    <td>Application secret key. It is obtained from the [ZEGOCLOUD Console](https://console.zegocloud.com/account/login).</td>
  </tr>
  <tr>
    <td>Timestamp</td>
    <td>Current Unix timestamp in seconds. The algorithm for generating the timestamp can be found in the signature example below. A maximum deviation of 10 minutes is allowed.</td>
  </tr>
</tbody>
</table>


<Warning title="Warning">

- **The values of SignatureNonce and Timestamp used to calculate the signature must be consistent with the values of SignatureNonce and Timestamp in the common parameters.**
- The generated signature is valid for 10 minutes. Please regenerate it if it exceeds the time limit.
</Warning>

2. Signature Generation Algorithm

Signature = md5(AppId + SignatureNonce + ServerSecret + Timestamp)


3. Signature string format

The signature is encoded in hex (lowercase) and has a length of 32 characters.

### 3.3 Signature example

ZEGOCLOUD provides signature example code in multiple programming languages for developers to refer to based on their actual situations.

<CodeGroup>
```Go title="Go"
  import (
    "crypto/md5"
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "log"
    "time"
  )
  // Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
  func GenerateSignature(appId uint32, signatureNonce string, serverSecret string, timestamp int64) (Signature string){
    data := fmt.Sprintf("%d%s%s%d", appId, signatureNonce, serverSecret, timestamp)
    h := md5.New()
    h.Write([]byte(data))
    return hex.EncodeToString(h.Sum(nil))
  }
  func main() {
    /* Generate a 16-digit hexadecimal random string */
    nonceByte := make([]byte, 8)
    rand.Read(nonceByte)
    signatureNonce := hex.EncodeToString(nonceByte)
    log.Printf(signatureNonce)
    appId := 12345       // Use your appId and serverSecret
    serverSecret := "9193cc662a4c0ec135ec71fb57194b38"
    timestamp := time.Now().Unix()
    /* appId:12345
       signatureNonce:4fd24687296dd9f3
       serverSecret:9193cc662a4c0ec135ec71fb57194b38
       timestamp:1615186943      2021/03/08 15:02:23
       signature:43e5cfcca828314675f91b001390566a
     */
    log.Printf("signature:%v", GenerateSignature(uint32(appId), signatureNonce, serverSecret, timestamp))
  }
  ```
```Python title="Python"
  # -*- coding: UTF-8 -*-
  import secrets
  import string
  import hashlib
  import time
  # Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
  def GenerateSignature(appId, signatureNonce, serverSecret, timestamp):
    str1 = str(appId) + signatureNonce + serverSecret + str(timestamp)
    hash = hashlib.md5()
    hash.update(str1.encode("utf8"))
    signature = hash.hexdigest()
    return signature

  def main():
    # Generate a 16-digit hexadecimal random string
    signatureNonce = secrets.token_hex(8)

    # Use your appId and serverSecret
    appId = 12345
    serverSecret = "9193cc662a4c0ec135ec71fb57194b38"
    # Get a 10-digit Unix timestamp
    timestamp = int(time.time())
    print(GenerateSignature(appId,signatureNonce,serverSecret,timestamp))

  if __name__ == '__main__':
    main()
  ```
```Java title="Java"
import java.security.MessageDigest;
import java.security.SecureRandom;
public class Md5{
    /**
    * Convert byte array to hexadecimal
    * @param bytes The byte array to be converted
    * @return The converted hexadecimal string
    */
    public static String bytesToHex(byte[] bytes) {
        StringBuffer md5str = new StringBuffer();
        // Convert each byte in the array to hexadecimal and concatenate them into an md5 string
        int digital;
        for (int i = 0; i < bytes.length; i++) {
            digital = bytes[i];
            if (digital < 0) {
                digital += 256;
            }
            if (digital < 16) {
                md5str.append("0");
            }
            md5str.append(Integer.toHexString(digital));
        }
        return md5str.toString();
    }
    // Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
    public static String GenerateSignature(long appId, String signatureNonce, String serverSecret, long timestamp){
        String str = String.valueOf(appId) + signatureNonce + serverSecret + String.valueOf(timestamp);
        String signature = "";
        try{
            // Create a MessageDigest object that implements the MD5 algorithm
            MessageDigest md = MessageDigest.getInstance("MD5");
            // Calculate the digest and get the byte array
            byte[] bytes = md.digest(str.getBytes("utf-8"));
            // Convert each byte in the array to hexadecimal and concatenate them into an md5 string
            signature = bytesToHex(bytes);
        }catch (Exception e) {
            e.printStackTrace();
        }
        return signature;
    }


    public static void main(String[] args){
        // Generate a random hexadecimal string (16 characters)
        byte[] bytes = new byte[8];

        // Use SecureRandom to get a strong random number generator
        SecureRandom sr = new SecureRandom();

        sr.nextBytes(bytes);
        String signatureNonce = bytesToHex(bytes);
        long appId = 12345L;       // Use your appId and serverSecret, add uppercase L or lowercase l after the number to indicate long type
        String serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
        long timestamp = System.currentTimeMillis() / 1000L;
        System.out.println(GenerateSignature(appId,signatureNonce,serverSecret,timestamp));
    }
}
```
```PHP title="PHP"
<?php
function GenerateSignature($appId, $signatureNonce, $serverSecret, $timestamp)
{
    $str = $appId.$signatureNonce.$serverSecret.$timestamp;
    $signature = md5($str);
    return $signature;
}

// Generate a random hexadecimal string (16 characters)
$signatureNonce = bin2hex(random_bytes(8));
// Use your appId and serverSecret
$appId = 12345;
$serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
$timestamp = time();
$signature = GenerateSignature($appId, $signatureNonce, $serverSecret, $timestamp);
echo $signature;
?>
```
```javascript title="Node.js"
const crypto = require('crypto'); 
// Signature=md5(AppId + SignatureNonce + ServerSecret + Timestamp)
function GenerateUASignature(appId, signatureNonce, serverSecret, timeStamp){
    const hash = crypto.createHash('md5'); // Use the MD5 algorithm in the hash algorithm
    var str = appId + signatureNonce + serverSecret + timeStamp;
    hash.update(str);
    // hash.digest('hex') means the output format is hexadecimal
    return hash.digest('hex');
}

var signatureNonce = crypto.randomBytes(8).toString('hex');
// Use your appId and serverSecret
var appId = 12345;
var serverSecret = "9193cc662a4c0ec135ec71fb57194b38";
var timeStamp = Math.round(Date.now()/1000);
console.log(GenerateUASignature(appId, signatureNonce, serverSecret, timeStamp));
```
</CodeGroup>
### 3.4 Return codes

When sending requests to the server API interface, there are the following response codes related to the signature. Developers should handle them according to the actual situation.

| Return Code | Description | Recommended Action|
| --- | --- | --- |
| 0 | Request successful. | - |
| 100000004 | Signature expired. | Please regenerate the signature. |
| 100000005 | Signature error. | Please verify if the parameters used to generate the signature are correct. |
