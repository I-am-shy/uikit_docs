#!/usr/bin/env python3
from __future__ import annotations

import json
import re
import sys
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Set, Tuple, Union


ROOT_DIR = Path(__file__).resolve().parent
# 以项目根目录为基准（本脚本位于 .scripts/check/ 下，因此向上两级）
PROJECT_ROOT = ROOT_DIR.parent.parent
# 配置文件默认名，若不存在将于 main 中尝试回退到 en 版本
DOCUO_CONFIG_PATH = (PROJECT_ROOT / "docuo.config.json").resolve()
RESULT_PATH = ROOT_DIR / "sidebars_result.json"


@dataclass
class SidebarDocIssue:
    id: str
    label: Optional[str]
    articleID: Optional[Union[int, str]]
    nodePath: List[str]


@dataclass
class InstanceResult:
    id: Optional[str]
    path: str
    absPath: str
    sidebarsPath: Optional[str]
    sidebarsMissing: bool
    docsTotal: int
    docsValid: int
    docsInvalid: int
    missingIds: List[SidebarDocIssue]


def read_json(path: Path) -> Any:
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def strip_json_line_comments(text: str) -> str:
    """
    去除以 // 开头的行内注释（不在字符串字面量中的部分）。
    仅处理 // 注释，不处理 /* */。
    """
    result_lines: List[str] = []
    for line in text.splitlines():
        i = 0
        in_string = False
        escaped = False
        cut_index = None
        while i < len(line):
            ch = line[i]
            if not in_string:
                # 发现 // 开始注释
                if ch == '/' and i + 1 < len(line) and line[i + 1] == '/':
                    cut_index = i
                    break
                if ch == '"':
                    in_string = True
            else:
                if escaped:
                    escaped = False
                elif ch == '\\':
                    escaped = True
                elif ch == '"':
                    in_string = False
            i += 1
        if cut_index is not None:
            result_lines.append(line[:cut_index].rstrip())
        else:
            result_lines.append(line)
    return "\n".join(result_lines)


def remove_numeric_prefix(segment: str) -> str:
    # 移除开头的 1 个或多个数字和一个连字符，如 "04-", "1-", "123-"
    return re.sub(r"^\d+\-", "", segment)


def normalize_segment(segment: str) -> str:
    # 忽略前缀数字-
    segment = remove_numeric_prefix(segment)
    # 转小写
    segment = segment.lower()
    # 空格改为 -（连续空格合并为一个 -）
    segment = re.sub(r"\s+", "-", segment)
    return segment


def path_to_doc_id(relative_path: Path) -> str:
    # 去掉扩展名
    parts = list(relative_path.with_suffix("").parts)
    normalized_parts = [normalize_segment(p) for p in parts]
    return "/".join(normalized_parts)


def collect_valid_doc_ids(instance_dir: Path) -> Set[str]:
    valid_ids: Set[str] = set()
    if not instance_dir.exists():
        return valid_ids
    for path in instance_dir.rglob("*"):
        if path.is_file() and path.suffix.lower() in {".md", ".mdx"}:
            rel = path.relative_to(instance_dir)
            doc_id = path_to_doc_id(rel)
            valid_ids.add(doc_id)
    return valid_ids


def iter_doc_nodes(sidebars_obj: Any) -> Iterable[Tuple[Dict[str, Any], List[str]]]:
    """
    递归遍历 sidebars.json，产出 (node, nodePathLabels)。
    node 为包含键的对象（dict）；nodePathLabels 是到该节点的类别 label 路径。
    """
    def _walk(node: Any, breadcrumbs: List[str]):
        if isinstance(node, dict):
            node_type = node.get("type")
            if node_type == "category":
                label = node.get("label")
                items = node.get("items") or []
                new_breadcrumbs = breadcrumbs + ([label] if label else [])
                for child in items:
                    yield from _walk(child, new_breadcrumbs)
            elif node_type == "doc":
                yield node, breadcrumbs
            else:
                # 其他类型如 link/autogenerated 等忽略
                pass
        elif isinstance(node, list):
            for item in node:
                yield from _walk(item, breadcrumbs)
        elif isinstance(node, dict):
            # 已覆盖
            pass
        else:
            # 非结构项忽略
            pass

    yield from _walk(sidebars_obj, [])


def load_sidebars(instance_dir: Path) -> Tuple[Optional[Path], Optional[Any]]:
    sidebars_path = instance_dir / "sidebars.json"
    if not sidebars_path.exists():
        return None, None
    raw: Optional[str] = None
    try:
        raw = sidebars_path.read_text(encoding="utf-8")
        data = json.loads(raw)
    except Exception:
        # 兼容带 // 注释的 JSON
        try:
            if raw is None:
                raw = sidebars_path.read_text(encoding="utf-8")
            cleaned = strip_json_line_comments(raw)
            data = json.loads(cleaned)
        except Exception:
            return sidebars_path, None

    # 兼容 { "mySidebar": [...] } 或直接 [ ... ] 的结构
    if isinstance(data, dict):
        # 取第一个数组值作为侧边栏根（常见为 mySidebar）
        array_like = None
        for v in data.values():
            if isinstance(v, list):
                array_like = v
                break
        root = array_like if array_like is not None else data
    else:
        root = data
    return sidebars_path, root


def annotate_sidebars_file(sidebars_path: Path, invalid_ids: Set[str]) -> int:
    """
    在 sidebars.json 中为无效 id 的行末追加注释 "// id-incorrect"。
    返回本次新增标注的数量。
    """
    if not sidebars_path.exists() or not invalid_ids:
        return 0
    text = sidebars_path.read_text(encoding="utf-8")
    lines = text.splitlines()
    pattern = re.compile(r"(\"id\"\s*:\s*\")([^\"]+)(\")")
    updated = False
    added = 0
    for idx, line in enumerate(lines):
        if '"id"' not in line or 'id-incorrect' in line:
            continue
        m = pattern.search(line)
        if not m:
            continue
        value = m.group(2)
        if value in invalid_ids:
            # 仅在未标注时追加注释
            if 'id-incorrect' not in line:
                lines[idx] = line + " //id-incorrect"
                updated = True
                added += 1
    if updated:
        sidebars_path.write_text("\n".join(lines) + ("\n" if text.endswith("\n") else ""), encoding="utf-8")
    return added


def main() -> int:
    # 优先使用 docuo.config.json，不存在时回退到 docuo.config.en.json
    config_path = DOCUO_CONFIG_PATH
    if not config_path.exists():
        fallback_path = (PROJECT_ROOT / "docuo.config.en.json").resolve()
        if fallback_path.exists():
            config_path = fallback_path
            print(f"未找到 docuo.config.json，已回退使用: {config_path}")
        else:
            print(f"未找到配置文件: {DOCUO_CONFIG_PATH} 或 {fallback_path}")
            return 1

    try:
        config = read_json(config_path)
    except Exception as e:
        print(f"读取配置失败: {e}")
        return 1

    instances = config.get("instances") or []
    if not isinstance(instances, list):
        print("配置中的 instances 非数组")
        return 1

    results: List[InstanceResult] = []
    total_invalid = 0

    for inst in instances:
        inst_id = inst.get("id") if isinstance(inst, dict) else None
        inst_rel_path = inst.get("path") if isinstance(inst, dict) else None
        if not inst_rel_path:
            continue
        # 跳过 path 为 http(s) 的实例
        if isinstance(inst_rel_path, str) and inst_rel_path.strip().lower().startswith(("http://", "https://")):
            continue
        inst_dir = (PROJECT_ROOT / inst_rel_path).resolve()

        valid_ids = collect_valid_doc_ids(inst_dir)

        sidebars_path, sidebars_root = load_sidebars(inst_dir)
        if sidebars_root is None:
            res = InstanceResult(
                id=inst_id,
                path=inst_rel_path,
                absPath=str(inst_dir),
                sidebarsPath=str(sidebars_path) if sidebars_path else None,
                sidebarsMissing=True,
                docsTotal=0,
                docsValid=0,
                docsInvalid=0,
                missingIds=[],
            )
            results.append(res)
            continue

        issues: List[SidebarDocIssue] = []
        docs_total = 0
        docs_valid = 0
        for node, breadcrumbs in iter_doc_nodes(sidebars_root):
            docs_total += 1
            node_id = node.get("id")
            node_label = node.get("label")
            node_article_id = node.get("articleID")
            if isinstance(node_id, str) and node_id in valid_ids:
                docs_valid += 1
            else:
                issues.append(
                    SidebarDocIssue(
                        id=str(node_id),
                        label=str(node_label) if node_label is not None else None,
                        articleID=node_article_id,
                        nodePath=[str(x) for x in breadcrumbs if x is not None],
                    )
                )

        docs_invalid = docs_total - docs_valid
        total_invalid += docs_invalid

        # 将无效 id 收集为集合以便原文件标注
        invalid_id_set: Set[str] = set(mi.id for mi in issues if mi.id)
        # 写回标注
        try:
            annotate_sidebars_file(sidebars_path, invalid_id_set)
        except Exception:
            pass

        res = InstanceResult(
            id=inst_id,
            path=inst_rel_path,
            absPath=str(inst_dir),
            sidebarsPath=str(sidebars_path) if sidebars_path else None,
            sidebarsMissing=False,
            docsTotal=docs_total,
            docsValid=docs_valid,
            docsInvalid=docs_invalid,
            missingIds=issues,
        )
        results.append(res)

    total_instances = len(results)
    error_instances = [r for r in results if r.docsInvalid > 0 or r.sidebarsMissing]

    output = {
        "checkedAt": datetime.now(timezone.utc).isoformat(),
        "root": str(PROJECT_ROOT),
        "summary": {
            "totalInstances": total_instances,
            "instancesWithErrors": len(error_instances),
            "totalInvalidIds": total_invalid,
        },
        "instances": [
            {
                **asdict(r),
                # dataclass 中的对象字段（如 missingIds）需要转换
                "missingIds": [asdict(mi) for mi in r.missingIds],
            }
            for r in error_instances
        ],
    }

    with RESULT_PATH.open("w", encoding="utf-8") as f:
        json.dump(output, f, ensure_ascii=False, indent=2)

    print(f"校验完成，结果已写入: {RESULT_PATH}")
    return 0


if __name__ == "__main__":
    sys.exit(main())